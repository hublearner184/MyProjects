# 2026.1.12

---

## C++头文件在编译时需要编译吗？

头文件本身不直接编译，但会被包含到源文件中一起编译		编译流程：

1.预处理阶段：

```
#include <iostream>
```

会将头文件内容原样插入源文件中

2.编译阶段：

编译器处理合并后的代码，生成目标文件.obj,编译器所做的是打开这个文件并复制文件的所有内容（头文件）。

3.链接阶段：
         将多个目标文件链接成可执行文件

## 为什么C++能比Java、C#更充分利用硬件？

1.C++直接编译为机器码，直接CPU执行

2.Java编译为字节码，需要JVM（Java Virtual Machine）解释。具有平台无关性，所以常用于开发，因为开发效率高。

3.C++手动管理内存，零开销。Java自动优化，有停顿。

## Link Stage(链接)

一个C++程序可以被分割成多个C++源文件，但是必须得有一个main()，为什么？因为Linking时需要找到一个Entry Point，不管有多少个源文件，而这个Entry Point就是main函数。(当然可以自定义，可能非必须是main)

## 头文件中不能写函数体

因为这样会导致编译时，引用头文件的源文件都生成一个同样的即一模一样的代码，这样会导致在链接阶段时，机器无法识别链接哪个。

# 2026.1.13

---



## EDA嘉立创画PCB（Printed Circuit Board）

为什么VDD_3代表电源正极 VSS_3代表电源负极  为什么VSS要接GND？

### 命名的起源：MOS管工艺

这个命名规则源于 **MOSFET（金属氧化物半导体场效应晶体管）** 的制造工艺，这也是现代集成电路（如CPU、内存芯片）的基础。

**VDD**：最初指的是**漏极（Drain）** 的供电电压。

在MOS管中，漏极是电流的出口。所以 `VDD`就代表了给芯片内部MOS管漏极供电的电源正极。

**VSS**：最初指的是**源极（Source）** 的供电电压。

源极是电流的入口。在N-MOS管中，源极通常连接到最低的电位，也就是电路的公共参考点。所以 `VSS`就成为了电源负极的代名词。

# 2026.1.14

---



## PCB板焊接的基本原理

### 一个绝妙的比喻：PCB是“高速公路系统”，焊锡是“立交桥”

想象一下一个城市：

1. 

   **PCB板本身（那些绿色板子）**：就像已经规划好、修建好的**城市高速公路网**。板子里面已经用金属（铜）刻好了各种“道路”（你看不见的线路）。这些道路代替了乱七八糟的电线，规整又可靠。

2. 

   **电子元件（电阻、芯片、USB口等）**：就像**高速公路沿线的建筑**，比如**住宅区、商场、加油站**。它们本身有功能，但必须通过道路连接起来才能发挥作用。

3. 

   **焊锡**：就是连接每个建筑和高速公路的**立交桥和匝道**。你把元件放上去，用焊锡连接，就相当于给这个建筑修通了通往高速的匝道。

------

### 那么，“焊接”到底是怎么一回事？

焊接的本质，不是用焊锡当“胶水”去粘，而是做一个**坚固的“金属小桥”**。

1. 

   **准备工作**：PCB板上的焊盘（那些银色的圆点）和元件的金属引脚，就像是桥墩。

2. 

   **加热**：你用烙铁同时加热焊盘和引脚，让它们都变热。

3. 

   **上锡**：把焊锡丝送上去，焊锡遇热熔化，变成液态。这个液态的焊锡会**紧紧地包裹住**热的引脚和焊盘。

4. 

   **冷却成型**：当你移开烙铁，焊锡冷却，就会变成一个**坚固的金属疙瘩**。这个疙瘩把元件的引脚和PCB的焊盘**永久地、导电地**连接在了一起。

**关键点：** 焊锡本身是能导电的金属！所以，这座“金属小桥”既起到了**固定**元件的作用，又起到了**传输电信号**的作用。

------

### 为什么不用电线了？

你这个问题问得非常好！其实，**PCB里面的铜线就是代替了电线**！

- 

  **想想老式的大收音机**：打开后盖，里面全是乱糟糟的电线，像一团乱麻。容易断，也不好修。

- 

  **而现代的PCB板**：工程师把所有这些电线都“拍扁”了，用化学方法精准地“印刷”在了一塊绝缘的板子（通常是绿色的）内部或表面。这样：

  - 

    **更整齐**：不会缠在一起。

  - 

    **更可靠**：线路被保护在板子里，不容易断。

  - 

    **更小巧**：可以做得非常精密，手机电脑才能这么薄。

**所以，PCB本身就是一套集成的、高精度的“电线系统”。** 焊接就是把各个“零件”（元件）安装到这个系统指定的接口上。

------

### 总结一下，给小白的最简单流程：

1. 

   **PCB板**：已经内置了所有“电线”的底板。

2. 

   **你**：负责把正确的“零件”放到底板指定的位置上。

3. 

   **焊锡**：你的工具，用来修建连接“零件”和“底板电线”的**最后一座坚固的金属小桥**。

| 你的角色             | 相当于                                         |
| -------------------- | ---------------------------------------------- |
| **拿到一张PCB板**    | 拿到一张已经修好路的**城市地图**               |
| **把元件插到板子上** | 把**建筑**（如商场）放到地图上画好的位置       |
| **用焊锡焊接**       | 修建一条连接这个建筑和城市道路的**永久性匝道** |

**所以，你一焊上去，元件就能用了，是因为你通过焊锡，成功地把元件接入了PCB内部已经存在的、看不见的“电线网络”中，形成了完整的电路。** 

## 正则表达式和字符串的区别

字符串本质上是数据容器，是精准匹配，只有两个字符串完全相同才可以返回true，适用于固定文本处理。

正则表达式是模式描述语言，是模式匹配，语法比较复杂，拥有极高的灵活性，用于模式匹配、数据提取、验证，可读性低，维护困难。

## gitignore文件

.gitignore文件是一种特殊的配置文件，用来告诉Git哪些文件或目录应该被忽略，不纳入版本控制。用于排除编译产生的临时文件，敏感信息，操作系统生成的临时文件等。

## Github Desktop

相当于是指令GUI界面，更方便管理，更好用，相对于命令行配置来说不容易报错，同时管理代码方便，达到目的就可以。

## C++

### C++头文件

了解了#pragma once是防止头文件被重复引用而导致LINK ERROR，并且头文件可以增强代码的可读性以及可维护性。

### 如何在Visual Studio C++中调试代码

调试代码有两大部分分为断点和读取内存。调试代码的意义是Debug即Delete Bug。断点（Break Point）意为程序中调试器将中断的点，可以将断点设置在程序中的任何代码行上，当程序执行到这一行时便会暂停，挂起执行线程，我们便可以查看程序state，其实也就是程序内存状态	

# 2026.1.15

---



## ROS2机器人开发复盘1

### ROS2基础架构

工作空间结构: src/build/install/log

包创建:使用 ros2 create package命令

构建系统:ament (ROS2的构建系统)

包配置管理:package.xml（包依赖声明）

setup.py (Python包配置和入口点定义)

###  节点通信机制

每个Python文件都是一个独立的单元；节点是ROS2执行的基本单元

Topic通信(Publisher & Subscriber)

异步通信：发布\订阅模式    消息类型：Twist（速度控制） Pose（位姿）服务质量（QoS）：队列深度设置

这里对QoS进行解释（百度百科）：当网络发生拥塞的时候，所有的数据流都有可能被丢弃；为满足用户对不同应用不同服务质量的要求，就需要网络能根据用户的要求分配和调度资源，对不同的数据流提供不同的服务质量：对实时性强且重要的数据报文优先处理；对于实时性不强的普通数据报文，提供较低的处理优先级，网络拥塞时甚至丢弃。QoS应运而生。支持QoS功能的设备，能够提供传输品质服务；针对某种类别的数据流，可以为它赋予某个级别的传输优先级，来标识它的相对重要性，并使用设备所提供的各种优先级转发策略、拥塞避免等机制为这些数据流提供特殊的传输服务。配置了QoS的网络环境，增加了网络性能的可预知性，并能够有效地分配网络带宽，更加合理地利用网络资源。

服务（service）

同步通信：请求-响应模式

服务调用：生成海龟的spawn服务

### TF坐标变换

TFbroadcast（TF广播）发布变换消息  TFListener（TF监听器）

###  **坐标变换原理**

**父子坐标系**: world → turtle1, world → turtle2

**位姿表示**: 位置(x,y,z) + 方向(四元数)

**实时更新**: 持续发布海龟位姿

## C++

在Property或者说属性中去找。 

下面的路径可以使.exe文件放在一起，.obj中间文件放在一起，容易管理。

C++中输出目录$(SolutionDir)bin\$(Platform)\$(Configuration)\

C++中中间目录$(SolutionDir)bin\intermediates\$(Platform)\$(Configuration)\

三个循环语句

for(int i=0;i<n;i++)//一般是知道次数                    while(i < n)//一般是不知道次数

{                                                                                           {

}                                                                                           }

do//不常用 

{

}while();

三个控制流语句 continue,break,return

continue只能在loop中使用,表示进入这个循环的下一个迭代(iteration)

break主要出现在loop中,同时也可以出现在switch中,break表示跳出循环,即终止循环

return直接跳出函数

指针(raw pointer)

时刻记住--指针是一个整数,一种存储内存地址的数字

void* 指的是无类型的指针,而非空指针

```c++
#include <iostream>
int main()
{
	int var = 8;
	int* ptr = &var;
	*ptr = 10;//指针的逆用
	std::cin.get();
}
```

# 2026.1.16

---



## C++

### 用指针动态分配内存

并且可以利用memset()来进行内存初始化为0

 

```c++
void *memset(void* ptr,int value,size_t num)；
```

参数说明：ptr是指向要填充的内存块的指针；value是要设置的值；size_t是要设置的字节数。 

```c++
int* ptr;//(第一种方式声明指针，更加强调ptr是个int指针类型)
int *ptr;//(第二种方式声明指针，更加强调ptr是个int类型)
int * ptr;//(第三种方式，但不常用)
int *a,*b;//(声明多指针)
int *a,b;//(代表着只有a是指针，b是int类型)
```

双指针说明：

```c++
char* Buffer = new Buffer[8];
memset(Buffer,0,8);
char** ptr = &Buffer;
```

我们来思考一下，第一句话创建了一个Buffer指针指向一个堆中的char类型的Buffer数组，当然是指向头一个也就是Buffer[0]的地址，而我们的第三句，双指针的定义，我们一定不要忘记指针的本质，也就是一个表示内存地址的整数,&Buffer就代表这个指针的内容实际上是Buffer[0]的地址。而我们的ptr指针呢，则表示一个随机分配的内存地址，这个内存地址中的内容表示Buffer[0]的地址，我们再根据这个地址，就能找到Buffer数组。（OK，经过AI检查，发现此处双指针理解的Buffer[0]的地址有误，实际上栈是存放局部变量的，也就是说这里的Buffer指针和ptr全都存储在栈中，而我们new出来的Buffer[]数组是存在堆中的，所以这里的内存地址中的内容表示的是Buffer变量的地址，并非Buffer[0]中的地址。by the way计算机中一般是小端存储方式，也即和LSB和人阅读顺序不一致。）

```c++
void Increment(int* value)
{
    value++;//代表着value所指的内存地址加1
    *value++;//代表着指针的逆用，即value所指的值+1
}

```

### 类

类只是对数据和功能组合在一起的一种方法。

为什么要引入类？假如拿游戏开发举例，如果要知道玩家的位置，那么我们可以

```c++
int PlayerX,PlayerY,PlayerZ;//(写玩家的坐标)然后给其赋值
```

但是明显有些大型游戏是多人在线并非只有一个Player，这时候在这样写代码就会变成

```c++
int Player1X,Player1Y,Player1Z;
int Player2X,Player2Y,Player2Z;
```

n个玩家，同样的该玩家对应的函数（动作之类）也有n个，这时候再去写是极其繁琐且不易维护的，所以我们引入了面向对象编程，也就是类，将所有玩家归为Player类。

```c++
class Player
{
    int x,y,z;
};
```

默认类创建变量是私有的，也就是只有在类所定义的函数中才可以使用，如果我们想让main()函数访问到类中的变量，我们需要对类中加public:

```c++
class Player
{
    public:
        int x,y,z;
        int speed;
};
int main()
{
    Player player;//声明一个Player类的变量player
    player.x = 5；//引用类中的公有变量
}
```

类中的函数称为方法，我们可以在上述代码中添加Move()函数

```c++
class Player
{
    public:
        int x,y,z;
        int speed;
        void Move(Player& player,int xa,int ya)
        {
            player.x = player.x + xa;
            player.y = player.y + ya;
        }
};
int main()
{
    Player player;//声明一个Player类的变量player
    player.x = 5；//引用类中的公有变量
}
```

OK，所以这里我的疑问是为什么void Move()中的int xa,int ya?而非int x,int y。

**可以写成 `int x, int y`，但不推荐这样做，原因如下：**

语法上允许，但会产生歧义

```c++
void Move(Player& player, int x, int y)  // 可以编译，但不推荐
{
    player.x = player.x + x;  // 这里的x是参数x
    player.y = player.y + y;  // 这里的y是参数y
}
```

可读性问题

```c++
// ❌ 混淆版本
void Move(Player& player, int x, int y)
{
    player.x = player.x + x;  // 哪个x是成员变量？哪个是参数？
    player.y = player.y + y;  // 代码阅读者需要仔细分辨
}

// ✅ 清晰版本
void Move(Player& player, int xa, int ya)
{
    player.x = player.x + xa;  // 明显是：player.x 加 参数xa
    player.y = player.y + ya;  // 一目了然
}
```

作用域混淆

```c++
class Player
{
    int x, y;  // 类成员变量
public:
    void Move(Player& player, int x, int y)  // 函数参数
    {
        // 在函数内部：
        // - 单独的 x 指的是参数
        // - player.x 指的是类成员变量
        // 这种命名冲突增加了认知负担
    }
};
```

更好的命名实践

```c++
// 方法1：使用有意义的参数名
void Move(Player& player, int deltaX, int deltaY)
{
    player.x += deltaX;  // += 是更好的写法
    player.y += deltaY;
}

// 方法2：使用"offset"等描述性名称
void Move(Player& player, int offsetX, int offsetY)
{
    player.x += offsetX;
    player.y += offsetY;
}

// 方法3：如果一定要用x,y，可以考虑使用this指针
void Move(int x, int y)  // 这是成员函数，应该去掉第一个参数
{
    this->x += x;  // 明确表示这是成员变量
    this->y += y;  // 但this->让代码变得冗长
}
```

实际上，你的代码设计本身可以优化：

```c++
class Player
{
public:
    int x, y, z;
    int speed;
    
    // ❌ 原始设计：需要传入Player&，但这是成员函数
    void Move(int xa, int ya)  // ✅ 改进：作为成员函数
    {
        x += xa * speed;  // 考虑速度因子
        y += ya * speed;
    }
    
    // 使用示例
    void Example()
    {
        Player player;
        player.Move(1, 1);  // 更自然的调用方式
    }
};
```

总结建议

| 方案                           | 可读性 | 可维护性 | 推荐程度   |
| ------------------------------ | ------ | -------- | ---------- |
| `Move(int x, int y)`           | 差     | 差       | ❌ 不推荐   |
| `Move(int xa, int ya)`         | 好     | 好       | ✅ 推荐     |
| `Move(int deltaX, int deltaY)` | 很好   | 很好     | ✅ 强烈推荐 |

**核心原则**：

避免名称遮蔽（避免参数名与成员变量同名）

使用描述性的参数名称

考虑将函数设计为成员函数而不是静态函数

### 结构体struct和类class的区别

从技术角度上来说，struct和class只有可见性的区别，struct默认全部public，class默认全部private，而struct一般用于简单的数据聚合，纯数据POD类型；class用于面向对象封装和完整的OOP设计，还有就是C++要兼容C。可以通过#define struct class来替换struct。
