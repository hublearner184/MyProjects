# 2026.2.1

## DS

### 核心代码模式与ACM模式

主要熟悉ACM标准，从零开始，然后输入输出也要写

核心代码就是只写出来关键的函数就可。

下面给出一个最基础的模板

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution{
public:
    vector<int> twoADD(vector<int>& nums,int target){
        
    }
};

int main(){
    vector<int> a;
    int b;
    for(int i = 0; i < a.size(); i++)
    {
        cin >> a;
        int result = Solution().twoADD(a,b);
        return result;
    }
    return 0;
}
```

就类似这个意思，代码可能瞎写。

### Leetcode 707.设计链表

选择采用虚拟头尾节点

1.同时持有头尾节点可以在O（1）的时间复杂度内完成在尾部添加元素的操作

2.在创建双链表时就创建一个虚拟头节点和一个虚拟尾节点，无论双链表是否为空，这两个节点都存在。这样就不会出现空指针的问题，可以避免很多边界情况的处理，比如以前要把在头部插入元素、在尾部插入元素和在中间插入元素几种情况分开讨论，现在有了头尾虚拟节点无论链表是否为空，都只需要考虑中间元素的插入情况就可以了。

3.关于内存泄漏C++最好实现手动删除元素。

```c++
#include <iostream>
#include <stdexcept>

template<typename E>
class MyLinkedList {
    // 虚拟头尾节点
    struct Node {
        E val;
        Node* next;
        Node* prev;

        Node(E value) : val(value), next(nullptr), prev(nullptr) {}
    };

    Node* head;
    Node* tail;
    int size;

public:
    // 构造函数初始化虚拟头尾节点
    MyLinkedList() {
        head = new Node(E());
        tail = new Node(E());
        head->next = tail;
        tail->prev = head;
        size = 0;
    }
};
```

这段代码实现了一个**带虚拟头尾节点（Dummy Nodes）的双向链表**的初始化。在算法题（如 LRU 缓存、高级链表操作）中，这种设计能极大简化逻辑，因为它消除了“空链表”和“处理头尾边界”的特例。

1. 模板与内部结构

```c++
template<typename E>
class MyLinkedList {
    // 结构体 Node 定义在类内部（私有）
    struct Node {
        E val;         // 存储的数据
        Node* next;    // 指向后继节点的指针
        Node* prev;    // 指向前驱节点的指针
        // 构造函数：使用我们之前学过的初始化列表
        Node(E value) : val(value), next(nullptr), prev(nullptr) {}
    };
```

- **嵌套结构体**：将 `Node` 定义在 `MyLinkedList` 内部，是因为这个结构体只为链表服务，起到了封装的作用。
- **双向指针**：每个节点既能“往后看”（next），也能“往前看”（prev）。

------

2. 类成员变量

```c++
    Node* head; // 指向虚拟头节点的指针
    Node* tail; // 指向虚拟尾节点的指针
    int size;   // 记录链表中实际有效元素的个数
```

- **虚拟节点（Sentinel/Dummy Nodes）**：这里的 `head` 和 `tail` **不存储实际数据**。它们就像链表的“两堵墙”，真正的元素被夹在它们中间。

------

3. 构造函数初始化逻辑

```c++
public:
    MyLinkedList() {
        head = new Node(E()); // 1. 在堆上创建一个虚拟头节点，值设为默认值
        tail = new Node(E()); // 2. 在堆上创建一个虚拟尾节点
```

- **`E()`**：调用类型 `E` 的默认构造函数（比如 `int` 就是 0）。
- **重要性**：这两个节点在链表整个生命周期内永远存在，**永远不会被删除**，除非销毁整个链表。

```c++
        head->next = tail;    // 3. 头的后面是尾
        tail->prev = head;    // 4. 尾的前面是头
        size = 0;             // 5. 初始有效长度为 0
    }
```

- **初始化状态**：此时链表虽然是“空”的，但内存中已经有了两个互相关联的节点

------

4.为什么要用虚拟头尾节点？（核心价值）

这是学习链表最重要的一课。在普通链表中，要插入一个节点，必须判断：**“是不是插入到了第一个位置？”** 如果是，要改 `head` 指针。

**有了虚拟节点后：**

- **任何时候**：要插入的节点，前面一定有一个节点（哪怕是 `head`），后面也一定有一个节点（哪怕是 `tail`）。
- **统一代码**：不需要写 `if (head == nullptr)` 这种判断了，所有的插入和删除逻辑都变成了一套通用的指针操作。

------

5. 避坑提醒

由于手动调用了 `new Node(E())`，在编写完整的类时，必须在析构函数（`~MyLinkedList`）中：

循环删除所有中间的有效节点。

最后一定要 `delete head;` 和 `delete tail;`**。 如果不删除这两个虚拟节点，依然会造成内存泄漏。

---

一套检查Index的丝滑小连招

```c++
bool isElementIndex(int index) const {
        return index >= 0 && index < size;
    }
    bool isPositionIndex(int index) const {
        return index >= 0 && index <= size;
    }
    void checkElementIndex(int index) const {
        if(!isElementIndex(index)){
            throw std::out_of_range("Index: " + std::to_string(index) + ", Size: " + std::to_string(size));
        }

    }
    void checkPositionIndex(int index) const {
        if(!isPositionIndex(index)){
            throw std::out_of_range("Index: " + std::to_string(index) + ", Size: " + std::to_string(size));
        }
    }
```

在 C++ 中，这里的 `const` 关键字被放置在成员函数的参数列表后面，表示该函数是一个 **常成员函数（Const Member Function）**。

1. 承诺“只读”：保护对象不被意外修改

当你在函数后面加上 `const`，你其实是向编译器和调用者做出了一个**硬性保证**：

- **这个函数绝不会修改类中的任何成员变量**（比如 `size` 或 `data` 的指向）。
- 如果在 `checkElementIndex` 内部你尝试写 `size = 10;`，编译器会直接报错，在编译阶段就拦截了潜在的 Bug。

------

2. 让“常对象”也能调用这些函数

这是最实际的用途。在 C++ 中，如果你定义了一个常对象（比如作为函数参数传递）：

C++

```
void printSize(const MyArrayList<int>& list) {
    // 因为 list 是 const 的，它只能调用带 const 标记的成员函数
    if (list.isElementIndex(0)) { 
        // ...
    }
}
```

- **如果不加 `const`**：即使 `isElementIndex` 逻辑上没改数据，编译器也会认为它“可能”改数据，从而禁止 `const` 对象调用它。
- **加上 `const`**：这个函数就进入了 `const` 对象的“白名单”。

# 2026.2.2

## DS

### 环形数组技巧及其实现

休

# 

# 2026.2.3

## DS

### cycle array

在队列的时候在详细解释

### 跳表

优化单链表查询索引的。时间复杂度可以降到logn级别

空间换时间

跳表（Skip List）是一种非常巧妙的**随机化**数据结构。如果你已经掌握了链表，那么理解跳表就会非常快：**跳表 = 多个层级的有序链表。**

它的核心思想是：**用空间换时间**。通过给有序链表增加“索引”层，将原本 $O(n)$ 的查找复杂度降低到了 **$O(\log n)$​**。

### bitset（位示图）

在实际开发和求解算法题的过程中，我们使用编程语言提供的布尔数组就够了，**除非需要处理的数据规模非常大，否则没必要为了节省这一点内存空间而引入位图这种结构**。

### 队列和栈

用链表实现栈：

```c++
// 用链表作为底层数据结构实现队列
#include <iostream>
#include <list>


template<typename E>
class MyLinkedQueue {
private:
    std::list<E> list;

public:
    // 向队尾插入元素，时间复杂度 O(1)
    void push(const E &e) {
        list.push_back(e);
    }

    // 从队头删除元素，时间复杂度 O(1)
    E pop() {
        E front = list.front();
        list.pop_front();
        return front;
    }

    // 查看队头元素，时间复杂度 O(1)
    E peek() {
        return list.front();
    }

    // 返回队列中的元素个数，时间复杂度 O(1)
    int size() {
        return list.size();
    }
};

int main() {
    MyLinkedQueue<int> queue;
    queue.push(1);
    queue.push(2);
    queue.push(3);

    std::cout << queue.peek() << std::endl; // 1
    std::cout << queue.pop() << std::endl; // 1
    std::cout << queue.pop() << std::endl; // 2
    std::cout << queue.peek() << std::endl; // 3

    return 0;
}
```

# 2026.2.4

## DS

### void addFirst(const E &e) { list.push_front(e); } 这里为什么要用const E &e

在 C++ 中，`const E &e` 是一种被称为 **“常量引用传参”** 的标准写法。它集合了**性能（快）**和**安全（稳）**两大优点，是编写工业级 C++ 代码的“金科律令”。

我们可以从以下三个核心理由来理解：

------

1. 性能优化：避免“昂贵的搬运”

如果直接写 `void addFirst(E e)`，这是**值传递**。

- **发生什么**：当你调用这个函数时，系统会创建 `e` 的一个**副本**（通过拷贝构造函数）。
- **代价**：如果 `E` 是一个简单的 `int`，开销很小；但如果 `E` 是一个存储了 100 万个字符的 `std::string` 或者你自定义的大型结构体，**拷贝一次会非常耗时且占用内存**。
- **引用的作用**：使用 `&`（引用），本质上是传递了原对象的**地址（或别名）**。无论对象多大，传递的开销都固定为一个指针的大小（通常是 8 字节）。

------

2. 安全保护：承诺“只读不改”

既然使用了引用，函数内部就拿到了原对象的“遥控器”。

- **潜在风险**：如果没有 `const`，函数内部不小心写了 `e = some_value;`，原对象就会被莫名其妙地修改。
- **const 的作用**：它相当于给函数戴上了“紧箍咒”。编译器会强制保证函数内部**只能读取 `e` 的值，绝不能修改它**。这样调用者就可以放心地把数据交给你，而不用担心数据被弄坏。

------

3. 增强兼容性：支持“临时变量”

这是一个非常高级且实用的特性。

如果你只写 `void addFirst(E &e)`（去掉 `const`）：

- 你**不能**这样调用：`stack.push(100);` 或者 `stack.push(a + b);`。
- **原因**：在 C++ 中，`100` 或 `a + b` 是**右值（临时对象）**，非静态引用不能绑定到临时对象上。
- **解决方案**：加上 `const` 后，`const E &` 既可以接收普通变量，也可以接收临时变量（字面量）。这让你的函数调用起来更加灵活。

### 哈希表

哈希表可以理解为一个加强版的数组

哈希表的伪代码

```c++
#include <iostream>
#include <vector>
using namespace std;

class MyHashMap{
    private:
        vector<void*> table; 
    public:
        void put(auto key,auto value){
            int index = hash(key);
            table[index] = value;
        }
        auto get(auto key){
            int index = hash(key);
            return table[index];
        }
        void remove(auto key){
            int index = hash(key);
            table[index] = nullptr;
        }
    private:
        int hash(auto key){

        }

};

int main(){

}
```

vector<void*>使用了万能指针理论上可以指向任何内存地址

关于auto关键字：
         当使用auto时，必须立即初始化变量，否则编译器不知道是什么类型。

简化冗长的类型：

在处理 STL 容器（如 `map` 或 `vector`）时，迭代器的类型非常恐怖。

- **传统写法**： `std::map<std::string, std::vector<int>>::iterator it = myMap.begin();`
- **使用 `auto`**： `auto it = myMap.begin();` *这极大提高了代码的可读性和编写速度

哈希表的key值唯一，但是value可以重复

### 哈希函数

哈希函数的作用是把任意长度的输入（key）转化成为固定长度的输出（索引）

如果设计的哈希函数的时间复杂度为O（N），那么哈希表的增删改查性能就会退化成O（N），所以哈希函数的性能很关键。

还要保证输入相同的key，输出也必须要相同，这样才能保证哈希表的正确性。

有一种方法：如何将不同类型的key转换为数值索引。Java中有个int hashCode函数是返回该对象的内存地址，这个地址是整数类型的而且全局唯一。转为索引时要注意是非负整数所以要&0x7fffffff，将符号位由1变为0（计算机组成原理中的内容），再对数组长度取%就落入了合法区间内。

### 哈希冲突

如果两个不同的key值通过一个hash函数得到了同一个value，就发生了哈希冲突。哈希冲突不可能避免，只能在算法层面妥善处理。hash函数相当于把一个无限大的空间映射到一个有限的索引空间，所以必然会有不同的key值映射到同一个索引上。

两种解决方法：线性探测再散列 和 拉链法

一个拉链法就是纵向，将底层的数组存储链表，然后多个不同的key映射到同一个value时就挂到链表上。

一个线性探测再散列法就是横向，映射到同一个value就index + 1，直到找到一个空的位置。

### 扩容和负载因子

负载因子是一个哈希表装满程度的度量。一般来说，负载因子越大，说明哈希表里面存储的key-value对越多，哈希冲突的概率就越大，哈希表的操作性能就越差。

size / table.length

上面的说明应该已经把哈希表的底层原理全部串起来了，最后模拟几个面试问题来总结一下本文的内容：

1、为什么我们常说，哈希表的增删查改效率都是 O(1)？

因为哈希表底层就是操作一个数组，其主要的时间复杂度来自于哈希函数计算索引和哈希冲突。只要保证哈希函数的复杂度在 O(1)，且合理解决哈希冲突的问题，那么增删查改的复杂度就都是 O(1)。

**2、哈希表的遍历顺序为什么会变化**？

因为哈希表在达到负载因子时会扩容，这个扩容过程会导致哈希表底层的数组容量变化，哈希函数计算出来的索引也会变化，所以哈希表的遍历顺序也会变化。

**3、哈希表的增删查改效率一定是 O(1)吗**？

不一定，正如前面分析的，只有哈希函数的复杂度是 O(1)，且合理解决哈希冲突的问题，才能保证增删查改的复杂度是 O(1)。

哈希冲突好解决，都是有标准答案的。关键是哈希函数的计算复杂度。如果使用了错误的 `key` 类型，比如前面用 `ArrayList` 作为 `key` 的例子，那么哈希表的复杂度就会退化成 O(N)。

**4、为啥一定要用不可变类型作为哈希表的 `key`**？

因为哈希表的主要操作都依赖于哈希函数计算出来的索引，如果 `key` 的哈希值会变化，会导致键值对意外丢失，产生严重的 bug。

### 拉链法实现哈希表

也是第一次进行容器的嵌套

```c++
#include <iostream>
#include <vector>
#include <list>
using namespace std;

class ExampleChainingHashMap{
    struct KVNode{
        int key;
        int value;
        KVNode(int key,int value):key(key),value(value){}
    };
    std::vector<std::list<KVNode>> table;
    public:
        ExampleChainingHashMap(int capacity):table(capacity){}
};
```

在堆内存中开辟一个长度为 `capacity` 的数组。每个槽位（`table[index]`）都会自动初始化为一个空的 `std::list<KVNode>`。

链表遍历时的操作

```c++
for(const auto& node : table[index]){
    if(node.key == key){
        return node.value;
    }
}
```

1. `const`：只读保护

- **作用**：承诺在循环过程中**不会修改** `table[index]` 链表里的任何数据。
- **好处**：如果你在循环体内部不小心写了 `node.value = 10;`，编译器会直接报错。这增强了代码的安全性，同时也告诉阅读代码的人：这只是一个“查找”操作。

2. `auto`：类型自动推导

- **作用**：让编译器自己去查 `table[index]` 里存的是什么。
- **背景**：`table[index]` 是一个 `std::list<KVNode>`。
- **推导结果**：编译器会自动识别出 `node` 的类型应该是 `KVNode`。
- **如果不写 auto**：你得写成 `for (const KVNode& node : ...)`。显然 `auto` 更简洁。

3. `&`：引用传递（性能核心）

**这是最重要的一点。**

- **如果不加 `&`**：代码会变成 `for (const auto node : ...)`。这意味着每遍历一个节点，编译器都会把链表里的 `KVNode` **拷贝一份**给变量 `node`。如果你的结构体很大，这会浪费大量的时间和内存。
- **加上 `&`**：变量 `node` 只是原数据的一个**别名（指针）**。它直接指向链表中已有的内存地址，**零拷贝**，速度极快。

4. `: table[index]`：遍历范围

- **作用**：指定要遍历的容器。
- **逻辑**：
  1. 编译器会自动调用 `table[index].begin()` 获取链表的起始位置。
  2. 自动调用 `table[index].end()` 作为结束条件。
  3. 每次循环自动执行 `++it`（移动到下一个节点）。

------

5. 整体翻译与等价代码

**这一行的“人话”翻译：**

> “请帮我从 `table[index]` 这个链表中，按顺序把每个节点拿出来。为了快，请直接用引用不要拷贝；为了安全，请把它设为只读。我就叫它 `node`。”

## C++

c++中的STL标准库中的vector和list容器可以调用的函数清单

| **功能分类** | **函数名**          | **说明**                            |
| ------------ | ------------------- | ----------------------------------- |
| **容量相关** | `size()`            | 返回当前元素个数                    |
|              | `empty()`           | 检查容器是否为空（返回 bool）       |
|              | `clear()`           | 清空所有元素                        |
| **元素访问** | `front()`           | 获取第一个元素的**引用**            |
|              | `back()`            | 获取最后一个元素的**引用**          |
| **修改操作** | `push_back(e)`      | 在末尾添加元素                      |
|              | `pop_back()`        | 删除最后一个元素                    |
|              | `insert(it, e)`     | 在迭代器指定位置插入元素            |
|              | `erase(it)`         | 删除迭代器指定位置的元素            |
| **迭代器**   | `begin()` / `end()` | 返回指向开头/末尾后一个位置的迭代器 |

2. vector 特有的常用函数

`vector` 的底层是连续内存，因此支持**随机访问**。

- **随机访问**：
  - `operator[]`：像数组一样访问，如 `v[i]`。
  - `at(i)`：带边界检查的访问（如果越界会抛出 `out_of_range` 异常，比 `[]` 更安全）。
- **容量管理**：
  - `capacity()`：返回当前分配的内存能装多少元素。
  - `reserve(n)`：**预留内存**。如果你知道要装 1000 个元素，先 reserve 可以避免多次扩容（resize）带来的性能开销。
  - `shrink_to_fit()`：请求释放多余的内存空间。
- **其他**：
  - `data()`：返回底层连续内存的原始指针。

3. list 特有的常用函数

`list` 是双向链表，不支持随机访问（不能 `l[i]`），但它支持高效的**头部操作**和**链表接纳**。

- **头部操作**：
  - `push_front(e)`：在最前面添加元素（$O(1)$）。
  - `pop_front()`：删除第一个元素（$O(1)$）。
- **链表专有逻辑**（这些操作在 list 上执行比通用算法更快）：
  - `sort()`：排序。**注意**：不能用 `std::sort(l.begin(), l.end())`，必须用 `l.sort()`。
  - `reverse()`：反转链表。
  - `unique()`：删除连续的重复元素。
  - `merge(list2)`：合并两个有序链表。
  - `splice(it, list2)`：将另一个链表的元素“接”到当前链表，不涉及内存拷贝，极快。
  - `remove(val)`：根据值直接删除所有匹配的元素。
