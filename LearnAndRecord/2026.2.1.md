# 2026.2.1

## DS

### 核心代码模式与ACM模式

主要熟悉ACM标准，从零开始，然后输入输出也要写

核心代码就是只写出来关键的函数就可。

下面给出一个最基础的模板

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution{
public:
    vector<int> twoADD(vector<int>& nums,int target){
        
    }
};

int main(){
    vector<int> a;
    int b;
    for(int i = 0; i < a.size(); i++)
    {
        cin >> a;
        int result = Solution().twoADD(a,b);
        return result;
    }
    return 0;
}
```

就类似这个意思，代码可能瞎写。

### Leetcode 707.设计链表

选择采用虚拟头尾节点

1.同时持有头尾节点可以在O（1）的时间复杂度内完成在尾部添加元素的操作

2.在创建双链表时就创建一个虚拟头节点和一个虚拟尾节点，无论双链表是否为空，这两个节点都存在。这样就不会出现空指针的问题，可以避免很多边界情况的处理，比如以前要把在头部插入元素、在尾部插入元素和在中间插入元素几种情况分开讨论，现在有了头尾虚拟节点无论链表是否为空，都只需要考虑中间元素的插入情况就可以了。

3.关于内存泄漏C++最好实现手动删除元素。

```c++
#include <iostream>
#include <stdexcept>

template<typename E>
class MyLinkedList {
    // 虚拟头尾节点
    struct Node {
        E val;
        Node* next;
        Node* prev;

        Node(E value) : val(value), next(nullptr), prev(nullptr) {}
    };

    Node* head;
    Node* tail;
    int size;

public:
    // 构造函数初始化虚拟头尾节点
    MyLinkedList() {
        head = new Node(E());
        tail = new Node(E());
        head->next = tail;
        tail->prev = head;
        size = 0;
    }
};
```

这段代码实现了一个**带虚拟头尾节点（Dummy Nodes）的双向链表**的初始化。在算法题（如 LRU 缓存、高级链表操作）中，这种设计能极大简化逻辑，因为它消除了“空链表”和“处理头尾边界”的特例。

1. 模板与内部结构

```c++
template<typename E>
class MyLinkedList {
    // 结构体 Node 定义在类内部（私有）
    struct Node {
        E val;         // 存储的数据
        Node* next;    // 指向后继节点的指针
        Node* prev;    // 指向前驱节点的指针
        // 构造函数：使用我们之前学过的初始化列表
        Node(E value) : val(value), next(nullptr), prev(nullptr) {}
    };
```

- **嵌套结构体**：将 `Node` 定义在 `MyLinkedList` 内部，是因为这个结构体只为链表服务，起到了封装的作用。
- **双向指针**：每个节点既能“往后看”（next），也能“往前看”（prev）。

------

2. 类成员变量

```c++
    Node* head; // 指向虚拟头节点的指针
    Node* tail; // 指向虚拟尾节点的指针
    int size;   // 记录链表中实际有效元素的个数
```

- **虚拟节点（Sentinel/Dummy Nodes）**：这里的 `head` 和 `tail` **不存储实际数据**。它们就像链表的“两堵墙”，真正的元素被夹在它们中间。

------

3. 构造函数初始化逻辑

```c++
public:
    MyLinkedList() {
        head = new Node(E()); // 1. 在堆上创建一个虚拟头节点，值设为默认值
        tail = new Node(E()); // 2. 在堆上创建一个虚拟尾节点
```

- **`E()`**：调用类型 `E` 的默认构造函数（比如 `int` 就是 0）。
- **重要性**：这两个节点在链表整个生命周期内永远存在，**永远不会被删除**，除非销毁整个链表。

```c++
        head->next = tail;    // 3. 头的后面是尾
        tail->prev = head;    // 4. 尾的前面是头
        size = 0;             // 5. 初始有效长度为 0
    }
```

- **初始化状态**：此时链表虽然是“空”的，但内存中已经有了两个互相关联的节点

------

4.为什么要用虚拟头尾节点？（核心价值）

这是学习链表最重要的一课。在普通链表中，要插入一个节点，必须判断：**“是不是插入到了第一个位置？”** 如果是，要改 `head` 指针。

**有了虚拟节点后：**

- **任何时候**：要插入的节点，前面一定有一个节点（哪怕是 `head`），后面也一定有一个节点（哪怕是 `tail`）。
- **统一代码**：不需要写 `if (head == nullptr)` 这种判断了，所有的插入和删除逻辑都变成了一套通用的指针操作。

------

5. 避坑提醒

由于手动调用了 `new Node(E())`，在编写完整的类时，必须在析构函数（`~MyLinkedList`）中：

循环删除所有中间的有效节点。

最后一定要 `delete head;` 和 `delete tail;`**。 如果不删除这两个虚拟节点，依然会造成内存泄漏。

---

一套检查Index的丝滑小连招

```c++
bool isElementIndex(int index) const {
        return index >= 0 && index < size;
    }
    bool isPositionIndex(int index) const {
        return index >= 0 && index <= size;
    }
    void checkElementIndex(int index) const {
        if(!isElementIndex(index)){
            throw std::out_of_range("Index: " + std::to_string(index) + ", Size: " + std::to_string(size));
        }

    }
    void checkPositionIndex(int index) const {
        if(!isPositionIndex(index)){
            throw std::out_of_range("Index: " + std::to_string(index) + ", Size: " + std::to_string(size));
        }
    }
```

在 C++ 中，这里的 `const` 关键字被放置在成员函数的参数列表后面，表示该函数是一个 **常成员函数（Const Member Function）**。

1. 承诺“只读”：保护对象不被意外修改

当你在函数后面加上 `const`，你其实是向编译器和调用者做出了一个**硬性保证**：

- **这个函数绝不会修改类中的任何成员变量**（比如 `size` 或 `data` 的指向）。
- 如果在 `checkElementIndex` 内部你尝试写 `size = 10;`，编译器会直接报错，在编译阶段就拦截了潜在的 Bug。

------

2. 让“常对象”也能调用这些函数

这是最实际的用途。在 C++ 中，如果你定义了一个常对象（比如作为函数参数传递）：

C++

```
void printSize(const MyArrayList<int>& list) {
    // 因为 list 是 const 的，它只能调用带 const 标记的成员函数
    if (list.isElementIndex(0)) { 
        // ...
    }
}
```

- **如果不加 `const`**：即使 `isElementIndex` 逻辑上没改数据，编译器也会认为它“可能”改数据，从而禁止 `const` 对象调用它。
- **加上 `const`**：这个函数就进入了 `const` 对象的“白名单”。

# 2026.2.2

## DS

### 环形数组技巧及其实现

休

# 

# 2026.2.3

## DS

### cycle array

在队列的时候在详细解释

### 跳表

优化单链表查询索引的。时间复杂度可以降到logn级别

空间换时间

跳表（Skip List）是一种非常巧妙的**随机化**数据结构。如果你已经掌握了链表，那么理解跳表就会非常快：**跳表 = 多个层级的有序链表。**

它的核心思想是：**用空间换时间**。通过给有序链表增加“索引”层，将原本 $O(n)$ 的查找复杂度降低到了 **$O(\log n)$​**。

### bitset（位示图）

在实际开发和求解算法题的过程中，我们使用编程语言提供的布尔数组就够了，**除非需要处理的数据规模非常大，否则没必要为了节省这一点内存空间而引入位图这种结构**。

### 队列和栈

用链表实现栈：

```c++
// 用链表作为底层数据结构实现队列
#include <iostream>
#include <list>


template<typename E>
class MyLinkedQueue {
private:
    std::list<E> list;

public:
    // 向队尾插入元素，时间复杂度 O(1)
    void push(const E &e) {
        list.push_back(e);
    }

    // 从队头删除元素，时间复杂度 O(1)
    E pop() {
        E front = list.front();
        list.pop_front();
        return front;
    }

    // 查看队头元素，时间复杂度 O(1)
    E peek() {
        return list.front();
    }

    // 返回队列中的元素个数，时间复杂度 O(1)
    int size() {
        return list.size();
    }
};

int main() {
    MyLinkedQueue<int> queue;
    queue.push(1);
    queue.push(2);
    queue.push(3);

    std::cout << queue.peek() << std::endl; // 1
    std::cout << queue.pop() << std::endl; // 1
    std::cout << queue.pop() << std::endl; // 2
    std::cout << queue.peek() << std::endl; // 3

    return 0;
}
```

