# 2026.2.1

## DS

### 核心代码模式与ACM模式

主要熟悉ACM标准，从零开始，然后输入输出也要写

核心代码就是只写出来关键的函数就可。

下面给出一个最基础的模板

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution{
public:
    vector<int> twoADD(vector<int>& nums,int target){
        
    }
};

int main(){
    vector<int> a;
    int b;
    for(int i = 0; i < a.size(); i++)
    {
        cin >> a;
        int result = Solution().twoADD(a,b);
        return result;
    }
    return 0;
}
```

就类似这个意思，代码可能瞎写。

### Leetcode 707.设计链表

选择采用虚拟头尾节点

1.同时持有头尾节点可以在O（1）的时间复杂度内完成在尾部添加元素的操作

2.在创建双链表时就创建一个虚拟头节点和一个虚拟尾节点，无论双链表是否为空，这两个节点都存在。这样就不会出现空指针的问题，可以避免很多边界情况的处理，比如以前要把在头部插入元素、在尾部插入元素和在中间插入元素几种情况分开讨论，现在有了头尾虚拟节点无论链表是否为空，都只需要考虑中间元素的插入情况就可以了。

3.关于内存泄漏C++最好实现手动删除元素。

```c++
#include <iostream>
#include <stdexcept>

template<typename E>
class MyLinkedList {
    // 虚拟头尾节点
    struct Node {
        E val;
        Node* next;
        Node* prev;

        Node(E value) : val(value), next(nullptr), prev(nullptr) {}
    };

    Node* head;
    Node* tail;
    int size;

public:
    // 构造函数初始化虚拟头尾节点
    MyLinkedList() {
        head = new Node(E());
        tail = new Node(E());
        head->next = tail;
        tail->prev = head;
        size = 0;
    }
};
```

这段代码实现了一个**带虚拟头尾节点（Dummy Nodes）的双向链表**的初始化。在算法题（如 LRU 缓存、高级链表操作）中，这种设计能极大简化逻辑，因为它消除了“空链表”和“处理头尾边界”的特例。

1. 模板与内部结构

```c++
template<typename E>
class MyLinkedList {
    // 结构体 Node 定义在类内部（私有）
    struct Node {
        E val;         // 存储的数据
        Node* next;    // 指向后继节点的指针
        Node* prev;    // 指向前驱节点的指针
        // 构造函数：使用我们之前学过的初始化列表
        Node(E value) : val(value), next(nullptr), prev(nullptr) {}
    };
```

- **嵌套结构体**：将 `Node` 定义在 `MyLinkedList` 内部，是因为这个结构体只为链表服务，起到了封装的作用。
- **双向指针**：每个节点既能“往后看”（next），也能“往前看”（prev）。

------

2. 类成员变量

```c++
    Node* head; // 指向虚拟头节点的指针
    Node* tail; // 指向虚拟尾节点的指针
    int size;   // 记录链表中实际有效元素的个数
```

- **虚拟节点（Sentinel/Dummy Nodes）**：这里的 `head` 和 `tail` **不存储实际数据**。它们就像链表的“两堵墙”，真正的元素被夹在它们中间。

------

3. 构造函数初始化逻辑

```c++
public:
    MyLinkedList() {
        head = new Node(E()); // 1. 在堆上创建一个虚拟头节点，值设为默认值
        tail = new Node(E()); // 2. 在堆上创建一个虚拟尾节点
```

- **`E()`**：调用类型 `E` 的默认构造函数（比如 `int` 就是 0）。
- **重要性**：这两个节点在链表整个生命周期内永远存在，**永远不会被删除**，除非销毁整个链表。

```c++
        head->next = tail;    // 3. 头的后面是尾
        tail->prev = head;    // 4. 尾的前面是头
        size = 0;             // 5. 初始有效长度为 0
    }
```

- **初始化状态**：此时链表虽然是“空”的，但内存中已经有了两个互相关联的节点

------

4.为什么要用虚拟头尾节点？（核心价值）

这是学习链表最重要的一课。在普通链表中，要插入一个节点，必须判断：**“是不是插入到了第一个位置？”** 如果是，要改 `head` 指针。

**有了虚拟节点后：**

- **任何时候**：要插入的节点，前面一定有一个节点（哪怕是 `head`），后面也一定有一个节点（哪怕是 `tail`）。
- **统一代码**：不需要写 `if (head == nullptr)` 这种判断了，所有的插入和删除逻辑都变成了一套通用的指针操作。

------

5. 避坑提醒

由于手动调用了 `new Node(E())`，在编写完整的类时，必须在析构函数（`~MyLinkedList`）中：

1. 循环删除所有中间的有效节点。
2. **最后一定要 `delete head;` 和 `delete tail;`**。 如果不删除这两个虚拟节点，依然会造成内存泄漏。