# 2026.2.1

## DS

### 核心代码模式与ACM模式

主要熟悉ACM标准，从零开始，然后输入输出也要写

核心代码就是只写出来关键的函数就可。

下面给出一个最基础的模板

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution{
public:
    vector<int> twoADD(vector<int>& nums,int target){
        
    }
};

int main(){
    vector<int> a;
    int b;
    for(int i = 0; i < a.size(); i++)
    {
        cin >> a;
        int result = Solution().twoADD(a,b);
        return result;
    }
    return 0;
}
```

就类似这个意思，代码可能瞎写。

### Leetcode 707.设计链表

选择采用虚拟头尾节点

1.同时持有头尾节点可以在O（1）的时间复杂度内完成在尾部添加元素的操作

2.在创建双链表时就创建一个虚拟头节点和一个虚拟尾节点，无论双链表是否为空，这两个节点都存在。这样就不会出现空指针的问题，可以避免很多边界情况的处理，比如以前要把在头部插入元素、在尾部插入元素和在中间插入元素几种情况分开讨论，现在有了头尾虚拟节点无论链表是否为空，都只需要考虑中间元素的插入情况就可以了。

3.关于内存泄漏C++最好实现手动删除元素。

```c++
#include <iostream>
#include <stdexcept>

template<typename E>
class MyLinkedList {
    // 虚拟头尾节点
    struct Node {
        E val;
        Node* next;
        Node* prev;

        Node(E value) : val(value), next(nullptr), prev(nullptr) {}
    };

    Node* head;
    Node* tail;
    int size;

public:
    // 构造函数初始化虚拟头尾节点
    MyLinkedList() {
        head = new Node(E());
        tail = new Node(E());
        head->next = tail;
        tail->prev = head;
        size = 0;
    }
};
```

这段代码实现了一个**带虚拟头尾节点（Dummy Nodes）的双向链表**的初始化。在算法题（如 LRU 缓存、高级链表操作）中，这种设计能极大简化逻辑，因为它消除了“空链表”和“处理头尾边界”的特例。

1. 模板与内部结构

```c++
template<typename E>
class MyLinkedList {
    // 结构体 Node 定义在类内部（私有）
    struct Node {
        E val;         // 存储的数据
        Node* next;    // 指向后继节点的指针
        Node* prev;    // 指向前驱节点的指针
        // 构造函数：使用我们之前学过的初始化列表
        Node(E value) : val(value), next(nullptr), prev(nullptr) {}
    };
```

- **嵌套结构体**：将 `Node` 定义在 `MyLinkedList` 内部，是因为这个结构体只为链表服务，起到了封装的作用。
- **双向指针**：每个节点既能“往后看”（next），也能“往前看”（prev）。

------

2. 类成员变量

```c++
    Node* head; // 指向虚拟头节点的指针
    Node* tail; // 指向虚拟尾节点的指针
    int size;   // 记录链表中实际有效元素的个数
```

- **虚拟节点（Sentinel/Dummy Nodes）**：这里的 `head` 和 `tail` **不存储实际数据**。它们就像链表的“两堵墙”，真正的元素被夹在它们中间。

------

3. 构造函数初始化逻辑

```c++
public:
    MyLinkedList() {
        head = new Node(E()); // 1. 在堆上创建一个虚拟头节点，值设为默认值
        tail = new Node(E()); // 2. 在堆上创建一个虚拟尾节点
```

- **`E()`**：调用类型 `E` 的默认构造函数（比如 `int` 就是 0）。
- **重要性**：这两个节点在链表整个生命周期内永远存在，**永远不会被删除**，除非销毁整个链表。

```c++
        head->next = tail;    // 3. 头的后面是尾
        tail->prev = head;    // 4. 尾的前面是头
        size = 0;             // 5. 初始有效长度为 0
    }
```

- **初始化状态**：此时链表虽然是“空”的，但内存中已经有了两个互相关联的节点

------

4.为什么要用虚拟头尾节点？（核心价值）

这是学习链表最重要的一课。在普通链表中，要插入一个节点，必须判断：**“是不是插入到了第一个位置？”** 如果是，要改 `head` 指针。

**有了虚拟节点后：**

- **任何时候**：要插入的节点，前面一定有一个节点（哪怕是 `head`），后面也一定有一个节点（哪怕是 `tail`）。
- **统一代码**：不需要写 `if (head == nullptr)` 这种判断了，所有的插入和删除逻辑都变成了一套通用的指针操作。

------

5. 避坑提醒

由于手动调用了 `new Node(E())`，在编写完整的类时，必须在析构函数（`~MyLinkedList`）中：

循环删除所有中间的有效节点。

最后一定要 `delete head;` 和 `delete tail;`**。 如果不删除这两个虚拟节点，依然会造成内存泄漏。

---

一套检查Index的丝滑小连招

```c++
bool isElementIndex(int index) const {
        return index >= 0 && index < size;
    }
    bool isPositionIndex(int index) const {
        return index >= 0 && index <= size;
    }
    void checkElementIndex(int index) const {
        if(!isElementIndex(index)){
            throw std::out_of_range("Index: " + std::to_string(index) + ", Size: " + std::to_string(size));
        }

    }
    void checkPositionIndex(int index) const {
        if(!isPositionIndex(index)){
            throw std::out_of_range("Index: " + std::to_string(index) + ", Size: " + std::to_string(size));
        }
    }
```

在 C++ 中，这里的 `const` 关键字被放置在成员函数的参数列表后面，表示该函数是一个 **常成员函数（Const Member Function）**。

1. 承诺“只读”：保护对象不被意外修改

当你在函数后面加上 `const`，你其实是向编译器和调用者做出了一个**硬性保证**：

- **这个函数绝不会修改类中的任何成员变量**（比如 `size` 或 `data` 的指向）。
- 如果在 `checkElementIndex` 内部你尝试写 `size = 10;`，编译器会直接报错，在编译阶段就拦截了潜在的 Bug。

------

2. 让“常对象”也能调用这些函数

这是最实际的用途。在 C++ 中，如果你定义了一个常对象（比如作为函数参数传递）：

C++

```
void printSize(const MyArrayList<int>& list) {
    // 因为 list 是 const 的，它只能调用带 const 标记的成员函数
    if (list.isElementIndex(0)) { 
        // ...
    }
}
```

- **如果不加 `const`**：即使 `isElementIndex` 逻辑上没改数据，编译器也会认为它“可能”改数据，从而禁止 `const` 对象调用它。
- **加上 `const`**：这个函数就进入了 `const` 对象的“白名单”。

# 2026.2.2

## DS

### 环形数组技巧及其实现

休

# 

# 2026.2.3

## DS

### cycle array

在队列的时候在详细解释

### 跳表

优化单链表查询索引的。时间复杂度可以降到logn级别

空间换时间

跳表（Skip List）是一种非常巧妙的**随机化**数据结构。如果你已经掌握了链表，那么理解跳表就会非常快：**跳表 = 多个层级的有序链表。**

它的核心思想是：**用空间换时间**。通过给有序链表增加“索引”层，将原本 $O(n)$ 的查找复杂度降低到了 **$O(\log n)$​**。

### bitset（位示图）

在实际开发和求解算法题的过程中，我们使用编程语言提供的布尔数组就够了，**除非需要处理的数据规模非常大，否则没必要为了节省这一点内存空间而引入位图这种结构**。

### 队列和栈

用链表实现栈：

```c++
// 用链表作为底层数据结构实现队列
#include <iostream>
#include <list>


template<typename E>
class MyLinkedQueue {
private:
    std::list<E> list;

public:
    // 向队尾插入元素，时间复杂度 O(1)
    void push(const E &e) {
        list.push_back(e);
    }

    // 从队头删除元素，时间复杂度 O(1)
    E pop() {
        E front = list.front();
        list.pop_front();
        return front;
    }

    // 查看队头元素，时间复杂度 O(1)
    E peek() {
        return list.front();
    }

    // 返回队列中的元素个数，时间复杂度 O(1)
    int size() {
        return list.size();
    }
};

int main() {
    MyLinkedQueue<int> queue;
    queue.push(1);
    queue.push(2);
    queue.push(3);

    std::cout << queue.peek() << std::endl; // 1
    std::cout << queue.pop() << std::endl; // 1
    std::cout << queue.pop() << std::endl; // 2
    std::cout << queue.peek() << std::endl; // 3

    return 0;
}
```

# 2026.2.4

## DS

### void addFirst(const E &e) { list.push_front(e); } 这里为什么要用const E &e

在 C++ 中，`const E &e` 是一种被称为 **“常量引用传参”** 的标准写法。它集合了**性能（快）**和**安全（稳）**两大优点，是编写工业级 C++ 代码的“金科律令”。

我们可以从以下三个核心理由来理解：

------

1. 性能优化：避免“昂贵的搬运”

如果直接写 `void addFirst(E e)`，这是**值传递**。

- **发生什么**：当你调用这个函数时，系统会创建 `e` 的一个**副本**（通过拷贝构造函数）。
- **代价**：如果 `E` 是一个简单的 `int`，开销很小；但如果 `E` 是一个存储了 100 万个字符的 `std::string` 或者你自定义的大型结构体，**拷贝一次会非常耗时且占用内存**。
- **引用的作用**：使用 `&`（引用），本质上是传递了原对象的**地址（或别名）**。无论对象多大，传递的开销都固定为一个指针的大小（通常是 8 字节）。

------

2. 安全保护：承诺“只读不改”

既然使用了引用，函数内部就拿到了原对象的“遥控器”。

- **潜在风险**：如果没有 `const`，函数内部不小心写了 `e = some_value;`，原对象就会被莫名其妙地修改。
- **const 的作用**：它相当于给函数戴上了“紧箍咒”。编译器会强制保证函数内部**只能读取 `e` 的值，绝不能修改它**。这样调用者就可以放心地把数据交给你，而不用担心数据被弄坏。

------

3. 增强兼容性：支持“临时变量”

这是一个非常高级且实用的特性。

如果你只写 `void addFirst(E &e)`（去掉 `const`）：

- 你**不能**这样调用：`stack.push(100);` 或者 `stack.push(a + b);`。
- **原因**：在 C++ 中，`100` 或 `a + b` 是**右值（临时对象）**，非静态引用不能绑定到临时对象上。
- **解决方案**：加上 `const` 后，`const E &` 既可以接收普通变量，也可以接收临时变量（字面量）。这让你的函数调用起来更加灵活。

### 哈希表

哈希表可以理解为一个加强版的数组

哈希表的伪代码

```c++
#include <iostream>
#include <vector>
using namespace std;

class MyHashMap{
    private:
        vector<void*> table; 
    public:
        void put(auto key,auto value){
            int index = hash(key);
            table[index] = value;
        }
        auto get(auto key){
            int index = hash(key);
            return table[index];
        }
        void remove(auto key){
            int index = hash(key);
            table[index] = nullptr;
        }
    private:
        int hash(auto key){

        }

};

int main(){

}
```

vector<void*>使用了万能指针理论上可以指向任何内存地址

关于auto关键字：
         当使用auto时，必须立即初始化变量，否则编译器不知道是什么类型。

简化冗长的类型：

在处理 STL 容器（如 `map` 或 `vector`）时，迭代器的类型非常恐怖。

- **传统写法**： `std::map<std::string, std::vector<int>>::iterator it = myMap.begin();`
- **使用 `auto`**： `auto it = myMap.begin();` *这极大提高了代码的可读性和编写速度

哈希表的key值唯一，但是value可以重复

### 哈希函数

哈希函数的作用是把任意长度的输入（key）转化成为固定长度的输出（索引）

如果设计的哈希函数的时间复杂度为O（N），那么哈希表的增删改查性能就会退化成O（N），所以哈希函数的性能很关键。

还要保证输入相同的key，输出也必须要相同，这样才能保证哈希表的正确性。

有一种方法：如何将不同类型的key转换为数值索引。Java中有个int hashCode函数是返回该对象的内存地址，这个地址是整数类型的而且全局唯一。转为索引时要注意是非负整数所以要&0x7fffffff，将符号位由1变为0（计算机组成原理中的内容），再对数组长度取%就落入了合法区间内。

### 哈希冲突

如果两个不同的key值通过一个hash函数得到了同一个value，就发生了哈希冲突。哈希冲突不可能避免，只能在算法层面妥善处理。hash函数相当于把一个无限大的空间映射到一个有限的索引空间，所以必然会有不同的key值映射到同一个索引上。

两种解决方法：线性探测再散列 和 拉链法

一个拉链法就是纵向，将底层的数组存储链表，然后多个不同的key映射到同一个value时就挂到链表上。

一个线性探测再散列法就是横向，映射到同一个value就index + 1，直到找到一个空的位置。

### 扩容和负载因子

负载因子是一个哈希表装满程度的度量。一般来说，负载因子越大，说明哈希表里面存储的key-value对越多，哈希冲突的概率就越大，哈希表的操作性能就越差。

size / table.length

上面的说明应该已经把哈希表的底层原理全部串起来了，最后模拟几个面试问题来总结一下本文的内容：

1、为什么我们常说，哈希表的增删查改效率都是 O(1)？

因为哈希表底层就是操作一个数组，其主要的时间复杂度来自于哈希函数计算索引和哈希冲突。只要保证哈希函数的复杂度在 O(1)，且合理解决哈希冲突的问题，那么增删查改的复杂度就都是 O(1)。

**2、哈希表的遍历顺序为什么会变化**？

因为哈希表在达到负载因子时会扩容，这个扩容过程会导致哈希表底层的数组容量变化，哈希函数计算出来的索引也会变化，所以哈希表的遍历顺序也会变化。

**3、哈希表的增删查改效率一定是 O(1)吗**？

不一定，正如前面分析的，只有哈希函数的复杂度是 O(1)，且合理解决哈希冲突的问题，才能保证增删查改的复杂度是 O(1)。

哈希冲突好解决，都是有标准答案的。关键是哈希函数的计算复杂度。如果使用了错误的 `key` 类型，比如前面用 `ArrayList` 作为 `key` 的例子，那么哈希表的复杂度就会退化成 O(N)。

**4、为啥一定要用不可变类型作为哈希表的 `key`**？

因为哈希表的主要操作都依赖于哈希函数计算出来的索引，如果 `key` 的哈希值会变化，会导致键值对意外丢失，产生严重的 bug。

### 拉链法实现哈希表

也是第一次进行容器的嵌套

```c++
#include <iostream>
#include <vector>
#include <list>
using namespace std;

class ExampleChainingHashMap{
    struct KVNode{
        int key;
        int value;
        KVNode(int key,int value):key(key),value(value){}
    };
    std::vector<std::list<KVNode>> table;
    public:
        ExampleChainingHashMap(int capacity):table(capacity){}
};
```

在堆内存中开辟一个长度为 `capacity` 的数组。每个槽位（`table[index]`）都会自动初始化为一个空的 `std::list<KVNode>`。

链表遍历时的操作

```c++
for(const auto& node : table[index]){
    if(node.key == key){
        return node.value;
    }
}
```

1. `const`：只读保护

- **作用**：承诺在循环过程中**不会修改** `table[index]` 链表里的任何数据。
- **好处**：如果你在循环体内部不小心写了 `node.value = 10;`，编译器会直接报错。这增强了代码的安全性，同时也告诉阅读代码的人：这只是一个“查找”操作。

2. `auto`：类型自动推导

- **作用**：让编译器自己去查 `table[index]` 里存的是什么。
- **背景**：`table[index]` 是一个 `std::list<KVNode>`。
- **推导结果**：编译器会自动识别出 `node` 的类型应该是 `KVNode`。
- **如果不写 auto**：你得写成 `for (const KVNode& node : ...)`。显然 `auto` 更简洁。

3. `&`：引用传递（性能核心）

**这是最重要的一点。**

- **如果不加 `&`**：代码会变成 `for (const auto node : ...)`。这意味着每遍历一个节点，编译器都会把链表里的 `KVNode` **拷贝一份**给变量 `node`。如果你的结构体很大，这会浪费大量的时间和内存。
- **加上 `&`**：变量 `node` 只是原数据的一个**别名（指针）**。它直接指向链表中已有的内存地址，**零拷贝**，速度极快。

4. `: table[index]`：遍历范围

- **作用**：指定要遍历的容器。
- **逻辑**：
  1. 编译器会自动调用 `table[index].begin()` 获取链表的起始位置。
  2. 自动调用 `table[index].end()` 作为结束条件。
  3. 每次循环自动执行 `++it`（移动到下一个节点）。

------

5. 整体翻译与等价代码

**这一行的“人话”翻译：**

> “请帮我从 `table[index]` 这个链表中，按顺序把每个节点拿出来。为了快，请直接用引用不要拷贝；为了安全，请把它设为只读。我就叫它 `node`。”

## C++

c++中的STL标准库中的vector和list容器可以调用的函数清单

| **功能分类** | **函数名**          | **说明**                            |
| ------------ | ------------------- | ----------------------------------- |
| **容量相关** | `size()`            | 返回当前元素个数                    |
|              | `empty()`           | 检查容器是否为空（返回 bool）       |
|              | `clear()`           | 清空所有元素                        |
| **元素访问** | `front()`           | 获取第一个元素的**引用**            |
|              | `back()`            | 获取最后一个元素的**引用**          |
| **修改操作** | `push_back(e)`      | 在末尾添加元素                      |
|              | `pop_back()`        | 删除最后一个元素                    |
|              | `insert(it, e)`     | 在迭代器指定位置插入元素            |
|              | `erase(it)`         | 删除迭代器指定位置的元素            |
| **迭代器**   | `begin()` / `end()` | 返回指向开头/末尾后一个位置的迭代器 |

2. vector 特有的常用函数

`vector` 的底层是连续内存，因此支持**随机访问**。

- **随机访问**：
  - `operator[]`：像数组一样访问，如 `v[i]`。
  - `at(i)`：带边界检查的访问（如果越界会抛出 `out_of_range` 异常，比 `[]` 更安全）。
- **容量管理**：
  - `capacity()`：返回当前分配的内存能装多少元素。
  - `reserve(n)`：**预留内存**。如果你知道要装 1000 个元素，先 reserve 可以避免多次扩容（resize）带来的性能开销。
  - `shrink_to_fit()`：请求释放多余的内存空间。
- **其他**：
  - `data()`：返回底层连续内存的原始指针。

3. list 特有的常用函数

`list` 是双向链表，不支持随机访问（不能 `l[i]`），但它支持高效的**头部操作**和**链表接纳**。

- **头部操作**：
  - `push_front(e)`：在最前面添加元素（$O(1)$）。
  - `pop_front()`：删除第一个元素（$O(1)$）。
- **链表专有逻辑**（这些操作在 list 上执行比通用算法更快）：
  - `sort()`：排序。**注意**：不能用 `std::sort(l.begin(), l.end())`，必须用 `l.sort()`。
  - `reverse()`：反转链表。
  - `unique()`：删除连续的重复元素。
  - `merge(list2)`：合并两个有序链表。
  - `splice(it, list2)`：将另一个链表的元素“接”到当前链表，不涉及内存拷贝，极快。
  - `remove(val)`：根据值直接删除所有匹配的元素。

# 2026.2.5

## DeepLearning

PyTorch的回顾：
上手快、方便调试、主流趋势

anaconda：包工具库。工具包又称为依赖包、模块、库、包。支持各个虚拟环境，各个环境之间可以独立切换。

pythonIDE

PyTorch

---



​	1. 强大的张量（Tensor）计算库

**张量**是 PyTorch 的基本数据结构，你可以把它看作是能在 GPU 上运行的“超级多维数组”。

- **GPU 加速**：与传统的 NumPy 数组不同，PyTorch 的张量可以无缝切换到 GPU（CUDA）上进行计算。
- **计算效率**：利用显卡的成千上万个核心并行处理矩阵运算，速度比 CPU 快几十到上百倍。

------

2. 自动求导系统 (Autograd)

这是深度学习模型能够“学习”的灵魂。

- **自动梯度计算**：当你构建一个神经网络（如 LSTM）时，PyTorch 会自动追踪你所有的数学运算，并自动计算梯度（即导数）。
- **反向传播**：它能够自动执行误差的反向传播，根据预测结果与真实电池寿命之间的差距，自动调整模型内部的参数。
- **科研友好**：你不需要手写复杂的数学求导公式，只需要定义好“前向传播”逻辑，PyTorch 帮你搞定剩下的训练细节。

------

3. 神经网络模块 (torch.nn)

PyTorch 提供了一套高度封装的“乐高积木”，让你能够快速搭建复杂的模型。

- **预定义层**：它内置了你毕设需要的 `nn.LSTM`、`nn.Conv1d`（一维卷积）以及 `nn.Linear`（全连接层）。
- **灵活性**：你可以像搭积木一样，把 CNN 和 LSTM 组合在一起。

------

4. 数据加载与处理 (torch.utils.data)

处理 NASA 或 CALCE 这种大型电池数据集时，内存管理非常重要。

- **DataLoader**：它可以帮你自动实现数据的批量处理（Batching）、乱序（Shuffling）以及多线程加载。
- **流式处理**：确保在训练时，GPU 不会因为等待数据从硬盘读取而“闲置”，实现高效的计算流水线。

------

5. 动态计算图 (Dynamic Computational Graph)

这是 PyTorch 区别于老版本 TensorFlow 的最大特点。

- **所见即所得**：代码的运行逻辑就是计算图的构建逻辑。这意味着你可以使用标准的 Python 调试工具（如 VS Code 的断点调试）来检查你的深度学习模型，这对于你调试复杂的特征融合逻辑非常友好。

## Tensor（张量）

从最简单的层面来看，张量是一个多维数组。它是对标量、向量、矩阵的更高维度抽象：

0维张量：标量（Scalar），就是一个单纯的数字

1维张量：向量（Vector），一排数字

2维张量：矩阵（Matrix），表格数据

3维张量及以上张量：多维数组。

## NumPy

1. 什么是 NumPy？

**NumPy**（Numerical Python）是一个开源的 Python 科学计算库。它提供了一个高性能的多维数组对象 **`ndarray`**（n-dimensional array），以及对这些数组进行操作的各种数学函数。

在你的毕设中，当你从 **NASA 或 CALCE 数据集**（通常是 `.csv` 或 `.mat` 格式）读取原始电池数据时，数据首先会被转化为 NumPy 数组，然后再进入 PyTorch 变成张量。

------

2. 核心对象：`ndarray`

这是 NumPy 的灵魂。与 Python 原生的列表（List）相比，`ndarray` 有以下特点：

- **同质性**：数组中的所有元素必须是相同类型的（例如全是 `float64`），这使得计算效率极高。
- **连续内存**：数据在内存中是连续存放的，这让 CPU 可以非常快速地访问。
- **矢量化运算**：你可以直接对整个数组进行数学运算（如 `a + b`），而不需要写繁琐的 `for` 循环。

# 2026.2.6

生病休

# 2026.2.7

## NumPy 与 PyTorch 的“亲密关系”

它们通常是这样协作的：

1. **数据清洗**：使用 NumPy 或 Pandas（基于 NumPy）处理原始电池电压、电流数据。
2. **特征提取**：利用 NumPy 快速计算 **ICA 曲线**（容量增量分析）。
3. **转换进入模型**：通过 `torch.from_numpy()` 将 NumPy 数组无缝转为 PyTorch 张量，交给 **RTX 3060** 训练。
4. **结果处理**：模型预测完后，再用 `.numpy()` 转回 NumPy，方便使用 `Matplotlib` 画出精美的 SOH 预测曲线图。

## 张量入门

```python
import torch  

x = torch.arange(12) //用arange创建一个行向量x。这个行向量包含以0开始的前12个整数。张量中的每个值都称为张量的元素
x.shape//访问张量的形状
x.numel()//张量中元素的总数
X = x.reshape(3,4)//想要改变一个张量的形状而不改变元素数量和元素值
X
torch.zeros((2,3,4)) //创建一个形状为(2,3,4)的张量，其中所有元素都设置为零 ones设置为1，torch.randn(3,4)随机初始化

torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])//我们还可以[**通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值**]。
在这里，最外层的列表对应于轴0，内层的列表对应于轴1。
```

在数学表示法中，我们将通过符号$f: \mathbb{R} \rightarrow \mathbb{R}$

来表示**一元**标量运算符（只接收一个输入）。

这意味着该函数从任何实数（$\mathbb{R}$）映射到另一个实数。

同样，我们通过符号$f: \mathbb{R}, \mathbb{R} \rightarrow \mathbb{R}$

表示**二元**标量运算符，这意味着该函数接收两个输入，并产生一个输出。

给定同一形状的任意两个向量$\mathbf{u}$和$\mathbf{v}$和二元运算符$f$，

我们可以得到向量$\mathbf{c} = F(\mathbf{u},\mathbf{v})$。

具体计算方法是$c_i \gets f(u_i, v_i)$，

其中$c_i$、$u_i$和$v_i$分别是向量$\mathbf{c}$、$\mathbf{u}$和$\mathbf{v}$中的元素。

在这里，我们通过将标量函数升级为按元素向量运算来生成向量值

$F: \mathbb{R}^d, \mathbb{R}^d \rightarrow \mathbb{R}^d$​。

---



在上面的部分中，我们看到了如何在相同形状的两个张量上执行按元素操作。

在某些情况下，即使形状不同，我们仍然可以通过调用广播机制（broadcasting mechanism）来执行按元素操作。

这种机制的工作方式如下：

1. 通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；
2. 对生成的数组执行按元素操作。

在大多数情况下，我们将沿着数组中长度为1的轴进行广播，如下例子：

```python
a = torch.arange(3).reshape((3, 1))

b = torch.arange(2).reshape((1, 2))

a, b
```

**索引和切片**

就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。

与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1；

可以指定范围以包含第一个元素和最后一个之前的元素。

如下所示，我们***可以用***`[-1]`***选择最后一个元素，可以用***`[1:3]`***选择第二个和第三个元素\***：

**节省内存**

原地操作

```python
Z = torch.zeros_like(Y)
print('id(Z):', id(Z))
Z[:] = X + Y
print('id(Z):', id(Z))
```

主要是Z[ : ] = X +Y

- **核心功能（原地操作）**：**关键点就在这个 `[:]`！**
- **含义**：
  1. 首先，系统计算 `X + Y` 的值，产生一个临时的结果。
  2. 然后，通过 `Z[:]` 语法，将计算出的结果**复制**到 `Z` 原先已经开辟好的那块内存空间里。
- **效果**：它没有改变 `Z` 的引用指向，只是刷新了 `Z` 内部存储的数据。这在 PyTorch 中被称为 **In-place 赋值**。

## 数据预处理

我们常用pandas来预处理原始数据，并将原始数据转换为张量格式。

### 读取数据集

举一个例子，我们首先(创建一个人工数据集，并存储在CSV（逗号分隔值）文件\)

*`../data/house_tiny.csv`*中。

以其他格式存储的数据也可以通过类似的方式进行处理。

下面我们将数据集按行写入CSV文件中

```python
import os

os.makedirs(os.path.join('..', 'data'), exist_ok=True)
data_file = os.path.join('..', 'data', 'house_tiny.csv')
with open(data_file, 'w') as f:
    f.write('NumRooms,Alley,Price\n')  # 列名
    f.write('NA,Pave,127500\n')  # 每行表示一个数据样本
    f.write('2,NA,106000\n')
    f.write('4,NA,178100\n')
    f.write('NA,NA,140000\n')
```

要[**从创建的CSV文件中加载原始数据集**]，我们导入*`pandas`*包并调用*`read_csv`*函数。该数据集有四行三列。其中每行描述了房间数量（“NumRooms”）、巷子类型（“Alley”）和房屋价格（“Price”）。

```python
# 如果没有安装pandas，只需取消对以下行的注释来安装pandas
# !pip install pandas
import pandas as pd

data = pd.read_csv(data_file)
print(data)
```

### 处理缺失值

```python
inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]
inputs = inputs.fillna(inputs.mean())
print(inputs)
```

这里的 `[:, 0:2]` 是 Python 数据分析库 **pandas** 中用于选取数据的一种**切片（Slicing）语法**。

具体来说，它是基于**位置索引（Integer Location）**来选取数据的。

 语法拆解

这段代码 `data.iloc[:, 0:2]` 的结构是 `data.iloc[行选择, 列选择]`。

1. **`.iloc`**：
   - 全称是 **Integer Location**。
   - 它的作用是**通过“行号”和“列号”**（即整数下标）来获取数据，而不是通过列名（如 "Age", "Price"）。
2. **逗号 `,`**：
   - 逗号的作用是分隔“行”和“列”。
   - 逗号**左边**控制取哪些行，**右边**控制取哪些列。
3. **逗号左边的 `:`**：
   - 单独一个冒号表示**“选取所有”**。
   - 在这里表示：**选取所有的行（从第一行到最后一行）**。
4. **逗号右边的 `0:2`**：
   - 这是切片范围，遵循 Python 的**“左闭右开”**原则（Start : Stop）。
   - `0` 表示起始列下标（包含）。
   - `2` 表示结束列下标（**不包含**）。
   - 所以，它选取的是 **第 0 列** 和 **第 1 列**。

## linear-algebra（补充）

dimension

请注意，**维度**（dimension）这个词在不同上下文时往往会有不同的含义，这经常会使人感到困惑。

为了清楚起见，我们在此明确一下：

**向量**或**轴**的维度被用来表示**向量**或**轴**的长度，即向量或轴的元素数量。

然而，张量的维度用来表示张量具有的轴数。

在这个意义上，张量的某个轴的维数就是这个轴的长度。

降维时调用求和函数会沿所有的轴降低张量的维度，使它变为一个标量。
