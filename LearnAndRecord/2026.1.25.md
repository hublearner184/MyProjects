# 2026.1.25

---



##  	c++

###   类的学习

```c++
#include <iostream>

class Log
{
public:
	const int LogLevelError = 0;
	const int LogLevelWarning = 1;
	const int LogLevelInfo = 2;
private:
	int m_LogLevel = LogLevelInfo;
public:
	void SetLevel(int level)
	{
		m_LogLevel = level;

	}
	void Error(const char* message)
	{
		if(m_LogLevel >= LogLevelError)
		    std::cout << "[ERROR]:" << message << std::endl;
	}
	void Warn(const char* message)
	{
		if(m_LogLevel >= LogLevelWarning)
		    std::cout <<"[WARNING]:" << message << std::endl;
	}
	void Info(const char* message)
	{
		if(m_LogLevel >= LogLevelInfo)
		    std::cout << "[Info]:" << message << std::endl;
	}
};

int main()
{
	Log log;
	log.SetLevel(log.LogLevelInfo);
	log.Warn("Hello!");
	log.Error("Hello!");
	log.Info("Hello!");
	std::cin.get();
}
```

粗略地定义一个类的方式：先在main函数中大体写出想要完成的功能，然后再在类中去补充说明。这个类实现的功能就是根据设置的m_LogLevel值来决定输出ERROR、WARN、还是Info。

### static关键字在c++中的作用

1.在类或结构体之外使用static关键字

当 `static` 修饰全局变量或函数时，它的主要作用是**限制作用域（Internal Linkage）**。

 静态全局变量/函数

- **隐藏性**：该变量或函数只在**当前源文件（编译单元）**内可见。其他文件即使使用 `extern` 也无法访问它。
- **避免命名冲突**：如果你在 `A.cpp` 和 `B.cpp` 中都定义了 `static int tool;`，它们是互不干扰的独立变量。

 静态局部变量（在函数内部）

- 虽然是在函数内，但也属于“类之外”的用法。
- **持久性**：变量在函数第一次被调用时初始化，但在函数运行结束后**不会被销毁**。下次调用该函数时，它会保留上一次的值。

2.在类或结构体之内使用static关键字

类内或结构体之内意味着该变量实际上将与类的所有实例共享内存。也就意味着该静态变量将在你在类中创建的所有实例当中只能有一个实例。

在static用于类成员时，它表示该成员属于类本身，而不是属于某个具体的对象实例

静态数据成员

- **共享性**：所有该类的对象共享同一个静态成员变量。无论创建多少个对象，内存中只有一个副本。
- **生命周期**：在程序启动时分配，程序结束时销毁，不随对象的创建和销毁而变化。
- **初始化**：通常需要在类外进行定义和初始化（除非是 `const static` 整数类型）。

静态成员函数

- **无 `this` 指针**：静态成员函数不属于任何对象，因此没有 `this` 指针。
- **访问限制**：它**只能直接访问**类的静态成员（变量或函数），不能直接访问非静态成员（因为非静态成员需要具体的对象实例）。 所以可以类名::静态变量 = value;

## AI中的MCP和Agent Skill

1. MCP (Model Context Protocol)

**MCP** 全称是 **Model Context Protocol（模型上下文协议）**，由 Anthropic 公司在 2024 年底推出。

 它是什么？

它是一套**通用的开放标准**。在此之前，如果你想让 AI 访问你的 GitHub、Google Drive 或本地数据库，每个开发者都要为不同的 AI 写一套不同的接口代码。 MCP 出现后，就像是为所有 AI 模型和数据源统一了“充电插头”。

 核心价值：

- **解耦**：模型（如 Claude, GPT）不需要针对每个工具写集成代码。
- **通用性**：只要数据源遵循 MCP 标准，任何支持 MCP 的 AI 客户端都能立刻读取这些数据。
- **上下文增强**：它让 AI 能安全地、实时地获取你本地或私有云中的信息，而不仅仅依赖于训练数据。

2. Agent Skill (智能体技能)

**Agent Skill**（通常也叫 Tools 或 Functions）是指赋予 AI 智能体的**特定能力或操作权限**。

 它是什么？

如果把大语言模型（LLM）比作“大脑”，那么 Agent Skill 就是它的“手”和“脚”。 原生的大模型只能“说”，但拥有 Skill 的 Agent 可以“做”。

 常见的 Skill 示例：

- **搜索技能**：调用 Google Search 获取最新新闻。
- **执行技能**：运行一段 Python 代码来画图。
- **操作技能**：给某人发邮件、在 Calendar 里订一个会议。
- **专业技能**：调用特定的 API 计算复杂的金融模型。

# 2026.1.26

---



## 关于一些CS资源网站的整理

github上star

1.labuladong的fucking algorithm

2.北大信科学长的CS-self-learning

很好的自学资源和指导，希望能根据个人情况加以合理利用以起到促进自身能力的作用。

## C++



# 2026.1.27

---



## 反思

到底应该以一种什么样的心态去学习，或者说到底怎么样可以在一个很独立的空间中去完成自己该完成的事情呢？我觉得这样才算是一种真正意义上的自己想干的事情和自律的体现，我的情绪波动并不会很大，我希望我可以在接下来的一个假期中养成习惯，不随波逐流，更难的是找到自己真正想要的东西。

## C++

 1.静态

```c++
#include <iostream>

class Singleton
{
private:
    // 1. 静态私有成员变量：保存类的唯一实例指针
    static Singleton* s_Instance;

public:
    // 2. 静态成员函数：全局访问点
    static Singleton& Get() { return *s_Instance; }

    void Hello() { std::cout << "Hello from Singleton!" << std::endl; }
};

// 3. 静态成员变量必须在类外进行初始化
Singleton* Singleton::s_Instance = nullptr;

int main()
{
    // 4. 调用方式：无需创建对象，直接通过类名访问
    Singleton::Get().Hello();
    std::cin.get();
}
```

2. 功能详细解释

(1) 静态成员变量 `s_Instance`

- **含义**：它是 `Singleton` 类的“自引用”指针。
- **作用**：由于它是 `static` 的，它不属于任何一个 `Singleton` 对象，而是属于类本身。这意味着在整个程序运行期间，这个指针**有且仅有一个**。

(2) 静态成员函数 `Get()`

- **含义**：这是一个全局访问接口。
- **作用**：因为它也是 `static` 的，你不需要先写 `Singleton myObj;` 就能调用它。通过 `Singleton::Get()`，程序中的任何地方都能拿到那个唯一的实例。

(3) 类外初始化

- `Singleton* Singleton::s_Instance = nullptr;`

- **含义**：C++ 规定类的静态非常量成员变量必须在类定义之外分配内存并初始化。这里将其初始化为空指针。

  

   2.ENUM（Enumeration枚举）

基本上是一种数值的集合。

# 2026.1.28

---



休

# 2026.1.29

---



## 数据结构与算法

转换下思路，C++对于我现在来说有点过于繁琐，有种因噎废食的感觉，明明机试的内容并不考察c++的大部分内容但是我还是在学，而且学的效率不高时间可能不够，我现在需要的是在出成绩之前把数据结构与算法的速成框架过一遍，完了再复习，这个优先级是最高的，然后就是每天抽空看看离散数学和数据库笔试内容。对，做事情要做成一定要有优先级，分清楚轻重缓急。

## 数组

回到了熟悉的数据结构与算法

### 静态数组

一块连续的内存空间，我们可以通过索引来访问该内存空间中的元素，数组的原始形态。

### 动态数组

编程语言为了方便我们使用，在静态数组的基础上添加了一些常用的API比如Push、Insert、remove等方法更方便我们去操作数组元素，不用自己写代码去实现这些操作。

```c++
memset(arr, 0, sizeof(arr));
```

第一个参数指向要填充的内存块的指针

第二个参数是要设置的ASCII值

第三个参数是要设置的总字节数

memset容易出现问题：memset是按字节填充的而不是按元素填充的

一个 `int` 通常占 4 个字节。当你执行 `memset(arr, 1, sizeof(arr))` 时，它并不是把数组元素变成 1，而是把每个字节都变成 `01`。

- **结果**：每个 `int` 会变成十六进制的 `0x01010101`，换算成十进制是 **16843009**，而不是 1。

只有再目标值是0、-1、0x3f时是安全的。

### 数据结构的基本操作就是增删改查

静态数组的增删查改操作的时间复杂度是：

- 增：
  - 在末尾追加元素：O(1)。
  - 在中间（非末尾）插入元素：O(N)。
- 删：
  - 删除末尾元素：O(1)。
  - 删除中间（非末尾）元素：O(N)。
- 查：给定指定索引，查询索引对应的元素的值，时间复杂度 O(1)。
- 改：给定指定索引，修改索引对应的元素的值，时间复杂度 O(1)。

### vector常用操作

```C++
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n = 10;
    // 数组大小为 10，元素值都为 0
    vector<int> nums(n);
    // 输出 0 (false)
    cout << nums.empty() << endl;
    // 输出：10
    cout << nums.size() << endl;

    // 在数组尾部插入一个元素 20
    nums.push_back(20);
    // 输出：11
    cout << nums.size() << endl;

    // 得到数组最后一个元素的引用
    // 输出：20
    cout << nums.back() << endl;

    // 删除数组的最后一个元素（无返回值）
    nums.pop_back();
    // 输出：10
    cout << nums.size() << endl;

    // 可以通过方括号直接取值或修改
    nums[0] = 11;
    // 输出：11
    cout << nums[0] << endl;

    // 在索引 3 处插入一个元素 99
    nums.insert(nums.begin() + 3, 99);

    // 删除索引 2 处的元素
    nums.erase(nums.begin() + 2);

    // 交换 nums[0] 和 nums[1]
    swap(nums[0], nums[1]);

    // 遍历数组
    // 0 11 99 0 0 0 0 0 0 0
    for (int i = 0; i < nums.size(); i++) {
        cout << nums[i] << " ";
    }
    cout << endl;
}
```
# 2026.1.30

---



## 动态数组的实现

### 自动扩/缩容

- 当数组元素个数达到底层静态数组的容量上限时，扩容为原来的 2 倍；
- 当数组元素个数缩减到底层静态数组的容量的 1/4 时，缩容为原来的 1/2。

### 索引越界的检查

下面的代码实现中，有两个检查越界的方法，分别是 `checkElementIndex` 和 `checkPositionIndex`，你可以看到它俩的区别仅仅在于 `index < size` 和 `index <= size`。

为什么 `checkPositionIndex` 可以允许 `index == size` 呢，因为这个 `checkPositionIndex` 是专门用来处理在数组中插入元素的情况。

比方说有这样一个 `nums` 数组，对于每个元素来说，合法的索引一定是 `index < size`：



```
nums = [5, 6, 7, 8]
index   0  1  2  3
```

但如果是要在数组中插入新元素，那么新元素可能的插入位置并不是元素的索引，而是索引之间的空隙：



```
nums = [ | 5 | 6 | 7 | 8 | ]
index    0   1   2   3   4
```

这些空隙都是合法的插入位置，所以说 `index == size` 也是合法的。这就是 `checkPositionIndex` 和 `checkElementIndex` 的区别。

### 删除元素时谨防内存泄漏

关于C++中内存泄漏问题：**逻辑删除 vs. 物理销毁**。

为了彻底理解，我们需要区分“简单类型（如 `int`）”和“复杂类型（如 `std::string` 或自定义类）”在内存中的表现。

------

1. 什么是“对象清理”？

在 `MyArrayList` 中，底层数组 `data` 的空间是预先申请好的。当 `size--` 时，只是在**逻辑上**告诉程序：“数组变短了”。

但实际上，内存里的二进制数据**并没有消失**。

如果 `E` 是 `int`：

即使你不写 `data[size - 1] = 0;` 也没关系。因为 `int` 只是 4 字节的数值，不占额外资源。下次 `add` 的时候，直接覆盖掉那个旧数字就行。

 如果 `E` 是 `std::string` 或自定义对象：

情况就完全不同了。看这个例子：

```c++
MyArrayList<std::string> list;
list.addLast("这是一个非常非常长的字符串，存放在堆内存中");
list.removeLast();
```

- **如果不写 `data[size-1] = E();`**：虽然 `size` 减小了，但 `data[size]` 那个位置依然存着那个 `string` 对象。而这个 `string` 对象内部持有一个指向外部堆内存的**指针**。只要你不手动重置它，那块“非常长的字符串”所占用的内存就一直不会被释放，直到整个 `MyArrayList` 被销毁。
- **如果写了 `data[size-1] = E();`**：这行代码创建了一个临时的空字符串对象，并赋值给当前位置。赋值操作会触发 `string` 内部的析构或内存释放机制，**立即收回**那块昂贵的堆内存。

## 构造函数与析构函数

构造函数是用于类对象实例的初始化，如果不初始化就会造成数据为某次遗留下来的没用的数据。

析构函数是用于类对象实例的销毁，卸载变量并清理你使用过的内存。

还有一点：为什么内存泄漏（Memory Leak）如此地被看重？

原因是因为：

1. 它是对系统资源的“非法侵占”

计算机的内存是有限的。内存泄漏的本质是：**程序申请了资源，但在使用完后没有归还，系统也无法将其分配给其他程序。**

- **后果**：随着程序运行时间的增加，系统可用内存越来越少。
- **现象**：刚开机时电脑很快，运行几个小时后变得越来越卡，最后连鼠标都动不了。

------

2. 隐蔽性：它是“慢速自杀”

如果程序代码写错了（比如除以 0 或数组越界），程序会**立即崩溃**，你很容易就能发现并修复它。

但内存泄漏不同：

- 你的程序在测试的前 10 分钟可能表现完美，完全看不出问题。
- 只有当它在服务器上连续运行几天、几周，或者处理海量数据时，才会因为内存耗尽（OOM, Out of Memory）而突然“猝死”。
- **这种 Bug 最难调试**，因为它往往发生在程序运行很久之后，很难复现。

------

3. 连锁反应：拖垮整个系统

在现代操作系统中，多个程序共享物理内存。

- 当你的程序由于内存泄漏把物理内存占满时，操作系统会被迫启动**交换机制（Swapping）**，将内存数据频繁读写到硬盘。
- **后果**：由于硬盘速度比内存慢几千倍，整个系统的性能会发生断崖式下跌。不仅你的程序会卡死，同一台电脑上的其他程序（甚至操作系统内核）也会受到牵连。

## 动态数组代码

```c++
#include <iostream>
#include <stdexcept>
#include <vector>

template<typename E>
class MyArrayList{
    private:
    E* data;//真正存储数据的底层数组

    int size;//当前元素个数

    int cap;//最大元素数量

    //默认初始容量
    static const int INIT_CAP = 1;
    public:
    MyArrayList(){
        this-> data = new E[INIT_CAP];
        this-> size = 0;
        this-> cap = INIT_CAP;
    }
    MyArrayList(int initCapacity){
        this-> data = new E[initCapacity];
        this-> size = 0;
        this-> cap = initCapacity;
    }
    void addLast(E e){
        if(size == cap){
            resize(2 * cap);
        }
        data[size] = e;
        size++;
    }
    void add(int index,E e)
    {
        checkPositionIndex(index);

        if(size == cap)
        {
            resize(2 * cap);
        }
        for(int i = size; i > index; i--){
            data[i] = data[i - 1];
        }
        data[index] = e;
        size++;
    }
    void AddFirst(E e){
        add(0,e);
    }
    E removeLast(){
        if(size == 0){
            throw std::out_of_range("No Such Element Exception");
        }
        if (size == cap / 4){
            resize(cap / 2);
        }
        E deletedVal = data[size - 1];
        data [size - 1] = E();
        size--;
        return deletedVal;
    }
    E remove(int index){
        checkElementIndex(index);
        if(size == cap / 4){
            resize(cap / 2);
        }
        E deletedVal = data[index];
        for(int i = index; i < size - 1; i++){
            data[i] = data[i + 1];
        }
        data[size - 1] = E();
        size--;
        return deletedVal;
    }
    E removeFirst(){
        return remove(0);
    }
    E get(int index){
        checkElementIndex(index);
        return data[index];
    }
    E set(int index,E element){
        checkElementIndex(index);
        E oldVal = data[index];
        data[index] = element;
        return oldVal;
    }
    int getSize(){
        return size;
    }
    bool isEmpty(){
        return size == 0;
    }
    void resize(int newCap){
        E* temp = new E[newCap];
        for(int i = 0; i < size; i++){
            temp[i] = data[i];
        }
        delete[] data;

        data = temp;
        cap = newCap;
    }
    bool isElementIndex(int index){
        return index >= 0 && index < size;
    }
    bool isPositionIndex(int index){
        return index >= 0 && index <= size;
    }
    void checkElementIndex(int index){
        if(!isElementIndex(index)){
            throw std::out_of_range("Index out of bounds");
        }
    }
    void checkPositionIndex(int index){
        if(!isPositionIndex(index)){
            throw std::out_of_range("Index out of bounds");
        }
    }
    void display(){
        std::cout << "ArrayList: size = " << size << ", capacity = " << cap << std::endl;
        for (int i = 0; i < size; i++){
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
    ~MyArrayList(){
        delete[] data;
    }
};
int main(){
    MyArrayList<int> arr(3);

    for(int i = 0;i <= 5; i++){
        arr.addLast(i);
    }
    arr.remove(3);
    arr.add(1,9);
    arr.AddFirst(100);
    int val = arr.removeLast();

    for(int i = 0; i < arr.getSize(); i++){
        std::cout << arr.get(i) << std::endl;
    }
    return 0;
}
```

