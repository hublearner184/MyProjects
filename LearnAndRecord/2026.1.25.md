# 2026.1.25

---



##  	c++

###   类的学习

```c++
#include <iostream>

class Log
{
public:
	const int LogLevelError = 0;
	const int LogLevelWarning = 1;
	const int LogLevelInfo = 2;
private:
	int m_LogLevel = LogLevelInfo;
public:
	void SetLevel(int level)
	{
		m_LogLevel = level;

	}
	void Error(const char* message)
	{
		if(m_LogLevel >= LogLevelError)
		    std::cout << "[ERROR]:" << message << std::endl;
	}
	void Warn(const char* message)
	{
		if(m_LogLevel >= LogLevelWarning)
		    std::cout <<"[WARNING]:" << message << std::endl;
	}
	void Info(const char* message)
	{
		if(m_LogLevel >= LogLevelInfo)
		    std::cout << "[Info]:" << message << std::endl;
	}
};

int main()
{
	Log log;
	log.SetLevel(log.LogLevelInfo);
	log.Warn("Hello!");
	log.Error("Hello!");
	log.Info("Hello!");
	std::cin.get();
}
```

粗略地定义一个类的方式：先在main函数中大体写出想要完成的功能，然后再在类中去补充说明。这个类实现的功能就是根据设置的m_LogLevel值来决定输出ERROR、WARN、还是Info。

### static关键字在c++中的作用

1.在类或结构体之外使用static关键字

当 `static` 修饰全局变量或函数时，它的主要作用是**限制作用域（Internal Linkage）**。

 静态全局变量/函数

- **隐藏性**：该变量或函数只在**当前源文件（编译单元）**内可见。其他文件即使使用 `extern` 也无法访问它。
- **避免命名冲突**：如果你在 `A.cpp` 和 `B.cpp` 中都定义了 `static int tool;`，它们是互不干扰的独立变量。

 静态局部变量（在函数内部）

- 虽然是在函数内，但也属于“类之外”的用法。
- **持久性**：变量在函数第一次被调用时初始化，但在函数运行结束后**不会被销毁**。下次调用该函数时，它会保留上一次的值。

2.在类或结构体之内使用static关键字

类内或结构体之内意味着该变量实际上将与类的所有实例共享内存。也就意味着该静态变量将在你在类中创建的所有实例当中只能有一个实例。

在static用于类成员时，它表示该成员属于类本身，而不是属于某个具体的对象实例

静态数据成员

- **共享性**：所有该类的对象共享同一个静态成员变量。无论创建多少个对象，内存中只有一个副本。
- **生命周期**：在程序启动时分配，程序结束时销毁，不随对象的创建和销毁而变化。
- **初始化**：通常需要在类外进行定义和初始化（除非是 `const static` 整数类型）。

静态成员函数

- **无 `this` 指针**：静态成员函数不属于任何对象，因此没有 `this` 指针。
- **访问限制**：它**只能直接访问**类的静态成员（变量或函数），不能直接访问非静态成员（因为非静态成员需要具体的对象实例）。 所以可以类名::静态变量 = value;

## AI中的MCP和Agent Skill

1. MCP (Model Context Protocol)

**MCP** 全称是 **Model Context Protocol（模型上下文协议）**，由 Anthropic 公司在 2024 年底推出。

 它是什么？

它是一套**通用的开放标准**。在此之前，如果你想让 AI 访问你的 GitHub、Google Drive 或本地数据库，每个开发者都要为不同的 AI 写一套不同的接口代码。 MCP 出现后，就像是为所有 AI 模型和数据源统一了“充电插头”。

 核心价值：

- **解耦**：模型（如 Claude, GPT）不需要针对每个工具写集成代码。
- **通用性**：只要数据源遵循 MCP 标准，任何支持 MCP 的 AI 客户端都能立刻读取这些数据。
- **上下文增强**：它让 AI 能安全地、实时地获取你本地或私有云中的信息，而不仅仅依赖于训练数据。

2. Agent Skill (智能体技能)

**Agent Skill**（通常也叫 Tools 或 Functions）是指赋予 AI 智能体的**特定能力或操作权限**。

 它是什么？

如果把大语言模型（LLM）比作“大脑”，那么 Agent Skill 就是它的“手”和“脚”。 原生的大模型只能“说”，但拥有 Skill 的 Agent 可以“做”。

 常见的 Skill 示例：

- **搜索技能**：调用 Google Search 获取最新新闻。
- **执行技能**：运行一段 Python 代码来画图。
- **操作技能**：给某人发邮件、在 Calendar 里订一个会议。
- **专业技能**：调用特定的 API 计算复杂的金融模型。

# 2026.1.26

## 关于一些CS资源网站的整理

github上star

1.labuladong的fucking algorithm

2.北大信科学长的CS-self-learning

很好的自学资源和指导，希望能根据个人情况加以合理利用以起到促进自身能力的作用。

## C++



# 2026.1.27

## 反思

到底应该以一种什么样的心态去学习，或者说到底怎么样可以在一个很独立的空间中去完成自己该完成的事情呢？我觉得这样才算是一种真正意义上的自己想干的事情和自律的体现，我的情绪波动并不会很大，我希望我可以在接下来的一个假期中养成习惯，不随波逐流，更难的是找到自己真正想要的东西。

## C++

 1.静态

```c++
#include <iostream>

class Singleton
{
private:
    // 1. 静态私有成员变量：保存类的唯一实例指针
    static Singleton* s_Instance;

public:
    // 2. 静态成员函数：全局访问点
    static Singleton& Get() { return *s_Instance; }

    void Hello() { std::cout << "Hello from Singleton!" << std::endl; }
};

// 3. 静态成员变量必须在类外进行初始化
Singleton* Singleton::s_Instance = nullptr;

int main()
{
    // 4. 调用方式：无需创建对象，直接通过类名访问
    Singleton::Get().Hello();
    std::cin.get();
}
```

2. 功能详细解释

(1) 静态成员变量 `s_Instance`

- **含义**：它是 `Singleton` 类的“自引用”指针。
- **作用**：由于它是 `static` 的，它不属于任何一个 `Singleton` 对象，而是属于类本身。这意味着在整个程序运行期间，这个指针**有且仅有一个**。

(2) 静态成员函数 `Get()`

- **含义**：这是一个全局访问接口。
- **作用**：因为它也是 `static` 的，你不需要先写 `Singleton myObj;` 就能调用它。通过 `Singleton::Get()`，程序中的任何地方都能拿到那个唯一的实例。

(3) 类外初始化

- `Singleton* Singleton::s_Instance = nullptr;`

- **含义**：C++ 规定类的静态非常量成员变量必须在类定义之外分配内存并初始化。这里将其初始化为空指针。

  

   2.ENUM（Enumeration枚举）

基本上是一种数值的集合。

# 2026.1.28

休

# 2026.1.29

## 数据结构与算法

转换下思路，C++对于我现在来说有点过于繁琐，有种因噎废食的感觉，明明机试的内容并不考察c++的大部分内容但是我还是在学，而且学的效率不高时间可能不够，我现在需要的是在出成绩之前把数据结构与算法的速成框架过一遍，完了再复习，这个优先级是最高的，然后就是每天抽空看看离散数学和数据库笔试内容。对，做事情要做成一定要有优先级，分清楚轻重缓急。

## 数组

回到了熟悉的数据结构与算法

### 静态数组

一块连续的内存空间，我们可以通过索引来访问该内存空间中的元素，数组的原始形态。

### 动态数组

编程语言为了方便我们使用，在静态数组的基础上添加了一些常用的API比如Push、Insert、remove等方法更方便我们去操作数组元素，不用自己写代码去实现这些操作。

```c++
memset(arr, 0, sizeof(arr));
```

第一个参数指向要填充的内存块的指针

第二个参数是要设置的ASCII值

第三个参数是要设置的总字节数

memset容易出现问题：memset是按字节填充的而不是按元素填充的

一个 `int` 通常占 4 个字节。当你执行 `memset(arr, 1, sizeof(arr))` 时，它并不是把数组元素变成 1，而是把每个字节都变成 `01`。

- **结果**：每个 `int` 会变成十六进制的 `0x01010101`，换算成十进制是 **16843009**，而不是 1。

只有再目标值是0、-1、0x3f时是安全的。

### 数据结构的基本操作就是增删改查

静态数组的增删查改操作的时间复杂度是：

- 增：
  - 在末尾追加元素：O(1)。
  - 在中间（非末尾）插入元素：O(N)。
- 删：
  - 删除末尾元素：O(1)。
  - 删除中间（非末尾）元素：O(N)。
- 查：给定指定索引，查询索引对应的元素的值，时间复杂度 O(1)。
- 改：给定指定索引，修改索引对应的元素的值，时间复杂度 O(1)。

### vector常用操作

```C++
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n = 10;
    // 数组大小为 10，元素值都为 0
    vector<int> nums(n);
    // 输出 0 (false)
    cout << nums.empty() << endl;
    // 输出：10
    cout << nums.size() << endl;

    // 在数组尾部插入一个元素 20
    nums.push_back(20);
    // 输出：11
    cout << nums.size() << endl;

    // 得到数组最后一个元素的引用
    // 输出：20
    cout << nums.back() << endl;

    // 删除数组的最后一个元素（无返回值）
    nums.pop_back();
    // 输出：10
    cout << nums.size() << endl;

    // 可以通过方括号直接取值或修改
    nums[0] = 11;
    // 输出：11
    cout << nums[0] << endl;

    // 在索引 3 处插入一个元素 99
    nums.insert(nums.begin() + 3, 99);

    // 删除索引 2 处的元素
    nums.erase(nums.begin() + 2);

    // 交换 nums[0] 和 nums[1]
    swap(nums[0], nums[1]);

    // 遍历数组
    // 0 11 99 0 0 0 0 0 0 0
    for (int i = 0; i < nums.size(); i++) {
        cout << nums[i] << " ";
    }
    cout << endl;
}
```
