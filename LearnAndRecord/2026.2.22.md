# 2026.2.22

## 损失函数

损失函数：衡量模型输出与真实标签的差异

代价函数：归结所有样本点求平均

目标函数：Cost+Regularization（正则化项控制过拟合）

### nn.CrossEntropyLoss

nn.LogSoftmax()与nn.NLLLoss()结合，进行交叉熵运算

主要参数：weight  ignore_index  reduction

### nn.NLLLoss

实现负对数似然函数中的负号功能

### nn.BCELoss

二分类交叉熵 输入值取值在[0,1]

### nn.BCEWithLogitsLoss

结合Sigmoid与二分类交叉熵  网络最后不加Sigmoid函数

### nn.L1Loss

MAE(平均绝对误差)

计算inputs与target之差的绝对值

### nn.MSELoss

MSE(平方误差)

计算inputs与target之差的平方

主要是用于回归任务

## 优化器（optimizer）

pytorch的优化器：管理并更新模型中可学习参数的值，使得模型输出更接近真实标签

### 学习率调整

梯度下降：wi+1 = wi - LR * g(wi)

学习率控制更新的步伐

class LRScheduler   主要属性：optimizer：关联的优化器 last_epoch：记录的epoch数

base_lrs:记录初始学习率  step()：更新下一个epoch的学习率   get_lr():计算下一个epoch的学习率

#### stepLR

stepLR 等间隔调整学习率  lr = lr * γ

#### MultiStepLR

按给定间隔调整学习率主要参数

milestones：设置调整时刻数       gamma：调整系数

# 2026.2.23

## 学习率

### ExponentialLR

功能：按指数衰减调整学习率

LR = LR * gamma ** epoch

gamma是指数的底

### CosineAnnealingLR

功能：余弦周期调整学习率

主要参数 T_max:下降周期   eta_min:学习率下限

### ReduceLRonPlateau

功能：监控指标，当指标不再变化则调整

### lambda自定义

## 可视化工具--TensorBoard

## Claude Code



# 2026.2.24

## 花朵分类

### 模型训练的代码框架

![image-20260224113402826](./2026.2.22.assets/image-20260224113402826.png)

### 下载数据集

https://www.robots.ox.ac.uk/~vgg/data/flowers/102/

dataset images 和 image labels

### 划分花朵的数据集

```python
#划分花朵数据集
import os
import random
if __name__ == "__main__":
#step1根据图像路径得到所有图像的列表
    img_dir = r"D:\data\flowers_data\jpg"
    img_list = [os.path.join(img_dir, name) for name in
                os.listdir(img_dir)]
    random.seed(10086)
    random.shuffle(img_list)
```

**`if __name__ == "__main__":`** 这是 Python 的一个标准用法。它的意思是：“如果当前这个脚本是被直接运行的（而不是被其他 Python 脚本当作模块导入的），那么就执行下面的代码”。这通常用于程序的入口点。

**`#step1根据图像路径得到所有图像的列表`** 这是一行单行注释（以 `#` 开头）。它不会被程序执行，仅仅是写给程序员看的，用来标记和说明接下来的代码是在做“获取图像列表”的第一步工作。

**`img_dir = r"D:\data\flowers_data\jpg"`** 这一行定义了一个名为 `img_dir` 的变量，用来存储图片所在的文件夹路径。 *注意字符串前面的小写字母 `r`*：它代表“原始字符串（raw string）”。在 Windows 系统中，路径通常使用反斜杠 `\`，而反斜杠在 Python 中默认是转义字符（比如 `\n` 代表换行）。加上 `r` 之后，Python 就会把 `\` 当作普通的斜杠处理，防止路径解析出错。

**`img_list = [os.path.join(img_dir, name) for name in os.listdir(img_dir)]`** 这是一句非常 Pythonic 的“列表推导式”，它把几步操作浓缩在了一行：

1. `os.listdir(img_dir)`：读取 `img_dir` 文件夹里面的所有文件和子文件夹的**名称**（仅仅是名字，比如 `image1.jpg`）。
2. `for name in ...`：遍历这些名称。
3. `os.path.join(img_dir, name)`：将原本的文件夹路径和文件名智能拼接起来，变成完整的文件路径（比如 `D:\data\flowers_data\jpg\image1.jpg`）。
4. 最终，这行代码生成了一个包含所有图片**完整路径**的列表，并把它赋值给变量 `img_list`。

**`random.seed(10086)`** 这行代码用于设置随机数生成器的“种子（seed）”为 `10086`。 在编程中，所谓的“随机”其实是伪随机。如果你设置了一个固定的种子，那么无论你运行这段代码多少次，接下来的随机操作（比如打乱顺序）得出的结果都将是**一模一样**的。这在模型训练时非常关键，可以保证你的实验结果是可复现的。

**`random.shuffle(img_list)`** 这行代码调用 `random` 模块的 `shuffle` 方法，直接对 `img_list` 这个列表进行“洗牌”（就地打乱列表里元素的顺序）。因为上一行设定了固定的种子 `10086`，所以每次运行这行代码时，列表被打乱后的最终顺序都是一致的。

```python
#step2根据比例获得训练集和验证集的列表 8:2
    train_ratio = 0.8
    valid_ratio = 0.2
    num_img = len(img_list)
    num_train = int(num_img * train_ratio)
    num_valid = num_img - num_train
    train_list = img_list[: num_train]
    valid_list = img_list[num_train: ]
```

**`train_ratio = 0.8`** 定义一个名为 `train_ratio` 的变量，将训练集所占的比例设置为 0.8（即 80%）。

**`vaild_ratio = 0.2`** 定义一个名为 `vaild_ratio` 的变量，将验证集所占的比例设置为 0.2（即 20%）。*（温馨提示：这里的单词拼写稍微有一点笔误，正确的拼写通常是 `valid_ratio`，但不影响程序的正常运行，只要后面保持一致即可。）*

**`num_img = len(img_list)`** 调用 Python 内置的 `len()` 函数，计算 `img_list` 里面一共有多少张图片的路径。这个总数被赋值给变量 `num_img`。

**`num_train = int(num_img \* train_ratio)`** 这行代码计算训练集应该包含多少张图片：

1. 先将图片总数乘以 0.8（`num_img * train_ratio`）。
2. 因为乘法得到的结果可能是一个带有小数的浮点数（比如总数是 101，乘出来是 80.8），而图片的数量必须是整数。所以这里使用了 **`int()`** 函数来进行向下取整，确保得到的 `num_train` 是一个整数。

**`num_valid = num_img - num_train`** 这行代码计算验证集应该包含多少张图片。它非常聪明地使用了**总数减去训练集数量**的方式，而不是使用 `int(num_img * vaild_ratio)`。这样做可以完美避免因为前面取整而导致的四舍五入误差，确保（训练集图片数 + 验证集图片数）绝对等于总图片数，没有任何遗漏。

**`train_list = img_list[: num_train]`** 这里使用了 Python 中非常强大的**列表切片（Slicing）**功能。`[: num_train]` 的意思是：从列表的最开始（索引 0）一直截取到索引为 `num_train` 的位置（**不包含** `num_train` 本身）。截取出来的这一大段列表被保存为 `train_list`，也就是我们的训练集。

**`valid_list = img_list[num_train: ]`** 同样是列表切片。`[num_train: ]` 的意思是：从索引 `num_train` 的位置开始，一直截取到列表的最后。因为前一步的截取刚好在 `num_train` 之前停下，所以这一步完美地接上了剩下的所有图片路径。截取出来的这一段被保存为 `valid_list`，即验证集。

```python
#step3根据列表把图像移动到新的文件夹下

    target_dir = os.path.abspath(os.path.dirname(img_dir))

    copy_file(train_list,target_dir,"train")

    copy_file(valid_list,target_dir,"valid")

def copy_file(img_list, target_dir, setname='train'):

    img_dir = os.path.join(target_dir,setname)

    os.makedirs(img_dir, exist_ok = True)

    for p in img_list:

        shutil.copy(p,img_dir)

    print(f"{setname} dataset: copy {len(img_list)} images to {img_dir}")
```

 核心功能函数 `copy_file`

这段代码定义了一个专门用来复制文件的“小工具”。

- **`def copy_file(img_list, target_dir, setname='train'):`** 定义了一个名为 `copy_file` 的函数。它接收三个参数：
  1. `img_list`：要处理的图片路径列表（比如前面生成的 `train_list` 或 `valid_list`）。
  2. `target_dir`：目标存放的总目录。
  3. `setname='train'`：子文件夹的名字。这里给了一个默认值 `'train'`，如果你调用函数时不写第三个参数，它就默认是 'train'。
- **`img_dir = os.path.join(target_dir,setname)`** 将目标总目录（`target_dir`）和子文件夹名（`setname`）拼接起来，得到最终存放图片的具体文件夹路径。比如拼接成 `D:\data\flowers_data\train`。
- **`os.makedirs(img_dir, exist_ok = True)`** 这是非常实用的一行代码！它的作用是**创建这个文件夹**。 `exist_ok = True` 是一个“护身符”：如果这个文件夹还不存在，它就会新建一个；如果这个文件夹**已经存在了**，程序也不会报错崩溃，而是静悄悄地继续往下执行。
- **`for p in img_list:`** 使用 `for` 循环，挨个遍历列表 `img_list` 里的每一个图片绝对路径，并把当前正在处理的路径暂存到变量 `p` 中。
- **`shutil.copy(p,img_dir)`** 调用 `shutil` 模块的 `copy` 方法，把路径为 `p` 的这张图片，**复制**一份到我们刚刚创建的 `img_dir` 文件夹里。
- **`print(f"{setname} dataset: copy {len(img_list)} images to {img_dir}")`** 任务完成后，打印一条提示信息报告战况。这里用了 Python 的 `f-string` 语法（字符串前面加 `f`），可以很方便地把变量的值塞进字符串里。比如打印出：“train dataset: copy 800 images to D:\data\flowers_data\train”。
